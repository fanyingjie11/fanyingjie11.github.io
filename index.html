<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fanyingjie11.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="飞得比别人高">
<meta property="og:type" content="website">
<meta property="og:title" content="夏天不热">
<meta property="og:url" content="https://fanyingjie11.github.io/index.html">
<meta property="og:site_name" content="夏天不热">
<meta property="og:description" content="飞得比别人高">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Yingjie Fan">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://fanyingjie11.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>夏天不热</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">夏天不热</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fanyingjie11.github.io/2022/05/05/Bigtable%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F.png">
      <meta itemprop="name" content="Yingjie Fan">
      <meta itemprop="description" content="飞得比别人高">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="夏天不热">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/05/Bigtable%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" class="post-title-link" itemprop="url">Bigtable论文阅读</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-05 16:31:17" itemprop="dateCreated datePublished" datetime="2022-05-05T16:31:17+08:00">2022-05-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-07 16:45:06" itemprop="dateModified" datetime="2022-05-07T16:45:06+08:00">2022-05-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/" itemprop="url" rel="index"><span itemprop="name">分布式存储</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" itemprop="url" rel="index"><span itemprop="name">论文阅读</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引言">引言</h1>
<p>Bigtable不完全支持关系模型，而是对用户提供简单的数据模型，动态控制数据格式和分布，可以让用户知道数据在底层存储的位置属性。Bigtable将col和row以及data看成字符串，用户通常将结构化或半结构化的数据序列化到字符串中。用户能够通过设计schema来控制数据的locality，同时能够控制哪些数据存放在内存。</p>
<h1 id="数据模式">数据模式</h1>
<p>一个运行Bigtable的服务器为多张表服务，表是一个分布式、稀疏、多维的有序map。组织数据的维度有三个：row、col、timestamp。</p>
<figure>
<img
src="/2022/05/05/Bigtable%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/image-20220505163137494.png"
alt="bigtable组织数据的三个维度" />
<figcaption aria-hidden="true">bigtable组织数据的三个维度</figcaption>
</figure>
<p>通过这三个维度唯一确定的数据称为一个cell。多行被group起来，成为负载均衡的单元，多列被group起来，成为访问控制和资源计数的单元。</p>
<p>一个典型表的例子如下：</p>
<figure>
<img
src="/2022/05/05/Bigtable%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/image-20220505163523817.png"
alt="一个table的示例" />
<figcaption aria-hidden="true">一个table的示例</figcaption>
</figure>
<p><strong>row：</strong>按照字母顺序排序，可以是任意字符串，通常大小为10-100byte，最大允许64KB，读写单行是可串行化的，即Bigtable支持单行事务，但不支持跨行事务。多行被group起来形成一个tablet，这是数据分布和负载均衡的单元。用户可以设计行键来得到较好的局部性。例如，上图中的示例，行键是URL的翻转，这样，所有CNN的网站数据就离得比较近。</p>
<p><strong>col：</strong>col被group成column
family，这是访问控制的单元。通常一个column
family内的所有列是同类数据（会被一起压缩）。Bigtable的设计思路是，一张表可以有很多列，但column
family很少。修改column family就需要修改表的schema，只有添加了一个column
family之后，column
family中的所有列才能添加数据，并且向这些col中添加数据不会影响schema。因为Bigtable不支持多行事务，所以删除一列可能不是原子的。访问控制和磁盘与内存的统计都是在column
family水平上。</p>
<p><strong>timestamps：</strong>时间戳就是64bit的整数，可以是系统设置也可由用户设置，例如上面的表例子中，每个contents列下面的cell都有多个版本的数据，由时间戳进行索引，其中最新的内容放在最前面。可以设置两种版本管理方式，一种是保留最新的n个版本数据，另外一种是保留某个时间段内的版本数据。</p>
<h1 id="api">API</h1>
<figure>
<img
src="/2022/05/05/Bigtable%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/image-20220507090300117.png"
alt="一个典型谷歌机器上的进程" />
<figcaption aria-hidden="true">一个典型谷歌机器上的进程</figcaption>
</figure>
<p>上图是谷歌服务器上面跑的典型进程，其中Bigtable可以用作mapreduce的输出和输出。</p>
<figure>
<img
src="/2022/05/05/Bigtable%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/image-20220507090440198.png"
alt="读写操作代码" />
<figcaption aria-hidden="true">读写操作代码</figcaption>
</figure>
<p>上图是Bigtable的API的简单操作，论文通过操作说明了用户可以做哪些操作。</p>
<h1 id="building-blocks">Building blocks</h1>
<p>Bigtable基于谷歌的一些基础设施，例如谷歌的集群管理系统（好像没有进一步介绍）用来进行作业调度、shared
machines 的资源管理、监控系统状态以及处理机器失效。</p>
<p>基于GFS存储日志和数据文件。</p>
<p>用SSTable来存储Bigtable的数据文件（参考leveldb）。SSTable提供了持久化、有序且不可更改的键值对map。键和值是任意字节的字符串。可以提供查找指定key的value，或在给定key的范围内进行迭代。SSTable内部包含一系列block（默认64KB，可配置），SSTable末尾有block
index，用来定位block，block
index被缓存到内存中，这样查找给定key只需要一次磁盘寻道，首先在内存中查找需要访问的block，然后访问磁盘读取对应block。SSTable能够被映射进内存中。</p>
<p>Bigtable依赖高可用和持久化的分布式锁服务Chubby。一个Chubby服务包含五个活跃副本，其中一个被选举为master，并响应请求。只要多数副本是活跃的并且能相互通信就可以了。Chubby使用Paxos算法实现副本一致性。</p>
<h1 id="实现">实现</h1>
<p>Bigtable的实现有三个主要组件，一个链接到每个客户端的库、一个master服务器、多个tablet服务器。tablet服务器能够动态加入或删除。</p>
<p>master负责将tablet分配给tablet服务器，检测tablet服务器的添加或过期，均衡tablet服务器的负载，GFS中垃圾回收。</p>
<p>每个tablet服务器管理多个tablet，处理它上面的tablet的读写请求，并在tablet较大时进行分割。</p>
<p>客户端不依赖master进行读写请求，因为客户端不通过master获取tablet的位置信息。客户端直接与tablet服务器进行通信。</p>
<p>论文中说，尽管模型支持任意大小的数据集，但建议客户单行数据不要超过几百GB（啊这，有点装逼的意思）</p>
<h2 id="tablet的位置">tablet的位置</h2>
<figure>
<img
src="/2022/05/05/Bigtable%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/image-20220507093902814.png"
alt="tablet的位置层级模式" />
<figcaption aria-hidden="true">tablet的位置层级模式</figcaption>
</figure>
<p>Chubby中包含了root tablet的位置信息，root tablet中包含了metadata
tablet的位置信息，metadata tablet包含用户tablet的位置信息。</p>
<p>Metadata tablet中每一行存储一个tablet所属的table
ID和tablet包含的最后一行的编码。tablet的位置信息存储在内存中，不需要访问GFS。</p>
<h2 id="tablet分配">tablet分配</h2>
<p>每个tablet最多的分配给一个tablet服务器，master跟踪活着的tablet服务器和当前的tablet到服务器的分配，以及哪些tablet未被分配。</p>
<p>Bigtable使用Chubby来跟踪tablet服务器，每个tablet服务器在一个指定的Chubby目录下创建名称唯一的文件，并获取其上的排他锁。master监控这个目录以发现tablet服务器。tablet服务器停止服务，如果它失去了排他锁，若该文件还存在，那么tablet服务器会重新请求一个排他锁，如果文件不存在，tablet服务器自杀。</p>
<p>master负责检测tablet服务器是否在提供服务，并尽快重新分配tablets。为了检测出不再提供服务的tablet服务器，master周期性地询问每个tablet服务器它的锁状态。如果tablet服务器报告锁不在它这，或者联系不上tablet服务器，则master尝试获取该tablet服务器的锁。如果master能够获取锁，那么说明Chubby是活着的，而tablet服务器要么死了，要么不能联系Chubby，所以master删除该tablet服务器对应的文件来指示该服务器不再提供服务。这样，master可以对该tablet服务器上的tablet进行重新分配。</p>
<p>在master的Chubby租约过期时，master自杀，保证就算master和Chubby之间的网络出现故障，系统也是健壮的。</p>
<p>当一个master被集群管理系统启动时，它需要发现当前的tablet分配信息。master在启动时需要执行的步骤是：</p>
<ol type="1">
<li>获取Chubby上的master lock，阻止并发master实例化。</li>
<li>查看Chubby上的servers目录，发现活着的服务器</li>
<li>与活着的tablet服务器通信，发现tablet分配信息，并通知tablet服务器新的master生成。</li>
<li>master查看Metadata
table，学习table集合。每碰见一个未分配的tablet，就添加到未分配集合中，使得该tablet能够有机会被分配。</li>
</ol>
<p>一个比较复杂的情况是，当metadata tablet没有被分配是，metadata
table不能被查询，所以，在开始第四步之前，如果root
tablet没有被发现，master就将root
tablet添加到未分配集合中。这样就能确保root tablet将被分配。因为root
tablet包含所有metadata tablet的信息，master将在查询root
tablet之后知道这些信息。</p>
<h2 id="tablet服务器">tablet服务器</h2>
<figure>
<img
src="/2022/05/05/Bigtable%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/image-20220507110728925.png"
alt="tablet的持久化状态" />
<figcaption aria-hidden="true">tablet的持久化状态</figcaption>
</figure>
<p>上图是tablet的持久化状态，更新被提交到commit log（redo
log），最近的提交被保存在内存中一个叫做memtable的有序缓冲中。旧的更新存放在SSTable中，是不可修改的。</p>
<p>为了恢复tablet，tablet服务器从Metadata
table中读取该tablet的元数据，包括组成该tablet的SSTable的列表、redo
point（指向commit log）。服务器通过重放redo point之后的commit
log来重构memtable。</p>
<p>当写操作到达，tablet服务器进行检查，确认发送方被授权进行修改。授权检查需要读取Chubby文件（通常在Chubby客户端中有缓存）。有效的修改被写入commit
log（采用了group
commit，提高小的写入操作的吞吐）。在写入被提交之后，写入的内容被插入memtable。</p>
<p>读操作也要检查授权等。SSTable和memtable提供一个合并的视图。由于SSTable和memtable是字母表排序的数据结构，因此查询高效。</p>
<h2 id="压缩">压缩</h2>
<p>这部分完全可以看看leveldb的设计思路，基本上是一致的。</p>
<p>随着写操作进行，memtable不断增大，达到一个门限以后，memtable被冻结并转换成SSTable，写入GFS。这个过程被称为<em>minor
compaction</em>。该过程主要目的有两个：一个是减少tablet服务器的内存使用，第二个是当数据丢失时，减少需要从commit
log读取的数据量。</p>
<p>每个minor compaction会创建一个SSTable，通过周期性地执行<em>merging
compaction</em>操作，将SSTable的数量限制在指定范围内。merging
compaction读取memtable和一些SSTable的数据，合并成一个SSTable，这样输入的memtable和SSTable就可被删除。</p>
<p>全部SSTable和memtable合并成一个SSTable的过程称为<em>major
compaction</em>，non-major
compactions可能还没有完全清除已经被删除的数据，而是打上标记，major
compaction之后将不存在任何已被删除的数据。major
compaction允许Bigtable回收被删除数据占用的资源。</p>
<p>Bigtable的读性能受益于GFS的局部性优化，GFS会把一份副本直接存在写者的本地磁盘。</p>
<h2 id="schema管理">schema管理</h2>
<p>Bigtable的schema存储在Chubby中，Chubby提供了写文件的原子性和小文件的一致性缓存。假如客户端想要删除某个column
family，首先master进行访问控制校验，验证删除操作有良好行为，然后通过重写Chubby中保存的schema文件，安装新的schema。当tablet服务器要确认某个column
family是否存在，只需要从Chubby读取对应的schema文件即可（通常缓存在服务器的Chubby客户端上）。由于Chubby的缓存是一致的，所以保证tablet服务器看得到所有修改。</p>
<h1 id="优化">优化</h1>
<p><strong>Locality Groups </strong>：用户可以指定每个column
family到一个Locality Group。一个tablet中的每个Locality
Group在压缩过程生成单独的SSTable。将通常不在一起访问的column
family分别放在不同的Locality Group可以有较好的读效率。针对每个Locality
Group有一个可调控的参数，例如一个Locality
Group可以被申明为存在内存中，Metadata
table就利用这个特性将tablet-location放到内存中。</p>
<p><strong>Compression</strong>：用户可以指定一个locality group
中的SSTable是否要压缩。SSTable中的每个block被分别压缩，这虽然损失了一定的磁盘空间，但这使得不用解压整个文件，一个SSTable的一小部分就能够被读取。论文着重强调了压缩速率和压缩空间。压缩比可以达到10-1。</p>
<p><strong>Caching for Read
Performance</strong>：tablet服务器有两种缓存，一种是Scan
Cache，是较高层次的缓存，缓存键值对，对于重复读写相同数据的应用来讲很有帮助。还有一种是Block
Cache，是较低层次的缓存，缓存的是通过GFS读取的SSTable的block，对于读取已经读到的数据附近的数据有帮助。</p>
<p><strong>Bloom
Filters</strong>：用来判断一个指定了row或column的数据是否在SSTable中，减少了磁盘访问次数。</p>
<p><strong>Commit-Log Implementation</strong>：commit
log不是每个tablet一份，而是一个tablet服务器一份，这样就避免了并发向GFS写日志，并且可以更好地利用group
commit。</p>
<p>但是这就引入了一个新问题，那就是当tablet服务器失效时，它所包含的tablet都要分配到其他许多服务器上，这些服务器都需要访问这个tablet服务器的commit
log，相当于读放大。为了解决该问题，采用了对commit log
entries进行排序的方法，按照&lt;table,row name,log sequence
number&gt;进行。这样，对某个特定的tablet，所有的记录都是连续的，因此可以被高效读取。为了并发排序，还将日志文件分割为64MB的片段，在不同的tablet服务器上排序不同的片段（这段没懂）。</p>
<p>为了保护写日志免受GFS延迟峰值的影响，采用两个线程写日志，一个时刻采用一个线程进行写入，如果写入很差，就换另外一个线程写。</p>
<p><strong>Speeding Up Tablet
Recovery</strong>：在unload一个tablet之前，tablet服务器首先做一次minor
compaction，在完成这次compaction之后，tablet服务器停止为该tablet提供服务，然后再做一次minor
compaction（这次很快），最后才会unload该tablet。这样做的好处是，消除了所有处于uncompacted状态的log，这样该tablet能够直接load到别的tablet服务器，而不需要恢复log
entry。</p>
<p><strong>Exploiting
Immutability</strong>：SSTable是不可修改的，这大大简化了系统很多方面的实现。例如：不需要在读取SSTable时提供同步访问，同时行级的并发控制很容易，因为只有memtable是可变的，为了减少拥塞，memtable采用了COW技术，允许读写并发。</p>
<p>后面两段没看懂hhh。。。</p>
<h1 id="性能分析">性能分析</h1>
<p>略过不谈</p>
<h1 id="经验">经验</h1>
<ol type="1">
<li>大规模分布式系统是很脆弱的</li>
<li>延迟添加新的特性，直到确定新特性将会被用到</li>
<li>系统级监测很有用</li>
<li>简单设计的价值</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fanyingjie11.github.io/2022/04/26/mapreduce%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F.png">
      <meta itemprop="name" content="Yingjie Fan">
      <meta itemprop="description" content="飞得比别人高">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="夏天不热">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/26/mapreduce%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" class="post-title-link" itemprop="url">mapreduce论文阅读</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-04-26 10:45:35 / 修改时间：17:08:08" itemprop="dateCreated datePublished" datetime="2022-04-26T10:45:35+08:00">2022-04-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/" itemprop="url" rel="index"><span itemprop="name">分布式存储</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" itemprop="url" rel="index"><span itemprop="name">论文阅读</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="问答">问答</h1>
<h2 id="mapreduce是干啥的">mapreduce是干啥的？</h2>
<p>答：mapreduce是一个编程模型，用来处理和生成大规模数据集。用户通过指定map和reduce函数以及输入数据等，将计算任务表达为mapreduce的任务。即使是没有分布式系统编程经验的程序员，也可以通过mapreduce来利用大规模集群，因为mapreduce帮助管理好一切，包括输入数据分区、调度多台机器上的程序执行、处理机器故障和管理机器间的通信等。</p>
<h2 id="为什么需要mapreduce">为什么需要mapreduce？</h2>
<p>谷歌内部有上百个需要处理大型数据集的专门实现，这些实现的缺点是掩盖了本来很简单的计算任务，因为需要处理数据分布、负载均衡、故障容错等问题。而mapreduce能够将简单的计算任务从复杂的分布式实现中剥离开来。</p>
<h1 id="编程模型">编程模型</h1>
<p>mapreduce的输入输出都是键值对，map和reduce函数由用户指定。map函数接收输入的键值对，并生成中间键值对，所有相同键的值会被组合起来，并被传递给reduce函数。reduce函数接收一个中间键以及该键的所有值。</p>
<h2 id="例子">例子</h2>
<p>wordcount：统计所有文件中每个单词出现的次数。</p>
<p>map和reduce函数的伪代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">map(String key, String value):</span><br><span class="line">// key: document name</span><br><span class="line">// value: document contents</span><br><span class="line">for each word w in value:</span><br><span class="line">EmitIntermediate(w, &quot;1&quot;);</span><br><span class="line"></span><br><span class="line">reduce(String key, Iterator values):</span><br><span class="line">// key: a word</span><br><span class="line">// values: a list of counts</span><br><span class="line">int result = 0;</span><br><span class="line">for each v in values:</span><br><span class="line">result += ParseInt(v);</span><br><span class="line">Emit(AsString(result));</span><br></pre></td></tr></table></figure>
<p>map函数接收一个文件名为key，文件内容为值的键值对，对于文件内容中每一个单词，都emit一个中间键值对，key是word，值是“1”。</p>
<p>reduce函数接收一个key为word，值为list的键值对，并合并所有的值，最终得到一个结果键值对，键还是word，值是合并的统计值。</p>
<h2 id="类型">类型</h2>
<figure>
<img
src="/2022/04/26/mapreduce%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/image-20220426170804898.png"
alt="image-20220426170804898" />
<figcaption aria-hidden="true">image-20220426170804898</figcaption>
</figure>
<p>论文中给出了通常map和reduce的输入输出类型。其中，中间键值对和输出键值对有相同的key。</p>
<p>在C++实现中，map和reduce的输入输出都是string类型，让用户来处理类型转换问题。</p>
<h1 id="实现">实现</h1>
<p>论文中提到针对不同的环境可以有不同的实现，他们针对的环境是谷歌内部的环境。</p>
<h2 id="执行流程">执行流程</h2>
<p>整个mapreduce的执行流程图如下。</p>
<ol type="1">
<li>首先将输入文件分割成M份，每份通常16MB至64MB（用户可指定）。将程序拷到集群的机器上。<code>这里可以看到，文件分割的大小和GFS底层chunk的大小相近</code></li>
<li>有一份特殊的程序拷贝，就是master。master需要将总共M个map
task和R个reduce task分配到空闲的机器上。</li>
<li>接收了map
task的worker，读取相应的文件块，解析键值对并传递给map函数，同时将生成的中间键值对缓存在内存中。</li>
<li>缓存的键值对被分区函数分为R份，并周期性地写入本地磁盘。这些写入位置被报告给master，master负责将这些信息通告reduce
worker。</li>
<li>reduce worker利用RPC读取map
worker生成的文件，对收集到的所有中间键值对进行排序，相同键的值被组合起来。</li>
<li>将排完序后的键值对传给reduce函数，将结果append到该reduce分区对应的输出文件中。</li>
<li>流程结束，返回用户代码。</li>
</ol>
<figure>
<img
src="/2022/04/26/mapreduce%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/image-20220426105253732.png"
alt="mapreduce工作流程图" />
<figcaption aria-hidden="true">mapreduce工作流程图</figcaption>
</figure>
<h2 id="master数据结构">master数据结构</h2>
<p>master为每个map和reduce函数存储了状态信息（idle, in-progress, or
completed)，并为每个非空闲任务记录worker的ID。</p>
<p>master还负责保存map生成文件的位置和大小，并传递给reduce worker。</p>
<h2 id="容错">容错</h2>
<p>主要的容错机制就是重试，master会周期性地ping每一个worker，如果超时就将该worker标记为故障，将该worker上所有map
task状态置为idle，允许这些task重新分配。对于失效worker上的reduce
task，处于in
progress状态的task会被标记为idle，以允许重新分配，而completed状态的reduce
task不需要重新执行，这时候由GFS来保证reduce
task的输出文件可用。（因为map
task生成的中间文件是写入本地磁盘而非GFS，所以失效worker上的completed的task也要重新执行）</p>
<h3 id="master失效">master失效</h3>
<p>虽然master有checkpoint机制，但论文中假定master不太可能失效，如果master失效就停止mapreduce任务，让用户检查并重试。</p>
<h3 id="出现失效时的语义">出现失效时的语义</h3>
<p>对于具有函数性的map和reduce函数（就是说相同的输入能得到相同的输出），mapreduce提供比较好的语义，即mapreduce的执行结果和没有失效发生时的执行结果是相同的。这个保证依赖于map和reduce执行结果的原子提交，文中只是简单提了一嘴。</p>
<p>对于非函数性的map或reduce
task，mapreduce不保证执行结果和不发生失效时执行结果完全一致。</p>
<h2 id="局部性">局部性</h2>
<p>master收集GFS中文件的位置信息，并将map
task放在尽量靠近输入数据的机器上，所以map
task中大多数输入数据的读取是locally的。</p>
<h2 id="任务粒度">任务粒度</h2>
<p>一共M个map task以及R个reduce
task，我们希望任务尽量细分，让M+R远大于机器总数，这样负载均衡效果好，并且如果某台机器失效，它上面的任务可以均衡分配至别的机器上。但是M+R也不能过大，一个实际的约束是空间消耗，例如master需要为每个task维护一些状态信息。</p>
<p>进一步，R通常由用户指定，通常选择一个合适的M，使得每个task的输入大小为16到64MB，这样可以利用局部性优化。R通常选取为机器数量多小的倍数。</p>
<h2 id="备份任务">备份任务</h2>
<p>主要是为了解决straggler
的问题，即某些task执行很慢，拖慢了整个mapreduce的进度。解决办法是在mapreduce任务接近完成时，将那些还为完成的task备份执行，即两个task同时执行相同的任务，这样只要一个完成了，那么这个task就完成了。</p>
<p>这样做增加了少量计算资源的开销，但任务执行时间显著减少。</p>
<h1 id="refinements">Refinements</h1>
<h2 id="分区函数partitioning-function">分区函数（Partitioning
Function）</h2>
<p>每个map
worker在生成中间文件时，需要分区函数来对数据进行划分，划分的数量由用户指定的reduce
task/输出文件个数所决定（每个reduce
task会生成一个输出文件）。默认的分区函数是哈希<code>hash(key) mod R</code>，这样负载均衡会很好。然而有时需要特殊的分区函数，例如，想要将所有相同host的url划分到相同分区，则可以选择分区函数<code>hash(Hostname(urlkey)) mod R</code>。</p>
<h2 id="顺序保证">顺序保证</h2>
<p>reduce
task在处理一个给定分区的数据时，会按照key升序进行处理（在读取完整的分区的中间数据后，reduce
worker会对数据进行排序），这样保证了输出文件是有序的。这样做的好处是，支持输出文件针对key的高效随机查询，或者方便了那些需要输出文件有序的用户。</p>
<h2 id="combiner-function">Combiner Function</h2>
<p>我们可以想象，map函数所emit的中间键值对中有很多重复的KEY，我们可以提前combine这些KEY，减少资源浪费。例如，wordCount中，由于齐夫定律，会出现很多重复的<code>&lt;the, 1&gt;</code>，可以提前进行合并。合并函数通常和reduce函数相同，不过输出文件位置不一样。</p>
<h1 id="性能测试">性能测试</h1>
<p>1800台机器的集群，每台机器4G内存、两个2GHz处理器、两个160G磁盘。两层交换机，根交换机聚合带宽100-200Gbps。这个环境和GFS中的类似。</p>
<h2 id="grep">Grep</h2>
<p>Grep任务需要从10^10个大小为100byte的记录中，筛选出符合特定模式的记录（92337条）。输入文件划分为64MB(M=
15000)，map的输出放在一个文件里（R=1）。</p>
<figure>
<img
src="/2022/04/26/mapreduce%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/image-20220426163554895.png"
alt="Grep执行过程中数据读取速率" />
<figcaption aria-hidden="true">Grep执行过程中数据读取速率</figcaption>
</figure>
<p>上图是输入数据的读取速率。峰值速率为30GB/s，这个时候集群中大多数节点都启动了，开始读取数据。后面map任务逐渐完成，读取速率开始下降。</p>
<h2 id="sort">Sort</h2>
<p>总数据量还是和Grep一样。map函数从每条记录中提取key，并emit提取的key和原始文本行。reduce函数为内置的Identity函数，原样输出得到的数据。</p>
<p>输入文件划分为64MB(M=
15000)，输出划分为4000个文件（R=4000）。分区函数使用key的初始几个字节，将数据划分为4000份。</p>
<p>这里的分区函数使用了先验的key分布知识，通常的排序需要预先对key进行采样，根据采样得到的分布进行数据分区。</p>
<figure>
<img
src="/2022/04/26/mapreduce%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/image-20220426164829004.png"
alt="Sort执行中的数据传输速率" />
<figcaption aria-hidden="true">Sort执行中的数据传输速率</figcaption>
</figure>
<p>上图为执行Sort任务时的数据传输速率，从最上方的图可以看到，map执行时的峰值速率为13GB，比前面Grep的要低，这是因为Sort中的map函数需要写入本地磁盘的中间数据量很大，这占用了大约一半的IO带宽。而Grep的中间数据大小可忽略。</p>
<p>中间的图是shuffling过程，即reduce worker从map
worker读数据的过程。可以看到，第一个map任务完成，reduce任务就立即开始读数据。有两个驼峰，第一个峰表示的是第一次批处理1700个reduce任务，大约300s处理完成，开始第二批任务，大约600s整个shuffling过程结束。可以看出shuffle的速率低于map阶段的输入速率，因为map阶段的读取基本都是local的，而shuffle有很多网络传输。</p>
<p>下面的图是reduce
worker写数据的速率。可以看到，从第一个shuffle完成到第一个reduce
worker开始写入，中间有一段时间间隔，因为中间数据需要进行排序。写入速率低于shuffle的速率，因为写入是往GFS里面写，要写双副本。</p>
<p>论文后面还分析了备份任务和故障恢复对性能的影响，这里就不列举了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fanyingjie11.github.io/2022/04/18/%E5%A6%82%E4%BD%95%E8%AE%A9markdown%E4%B8%AD%E5%85%AC%E5%BC%8F%E5%9C%A8hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%98%BE%E7%A4%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F.png">
      <meta itemprop="name" content="Yingjie Fan">
      <meta itemprop="description" content="飞得比别人高">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="夏天不热">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/18/%E5%A6%82%E4%BD%95%E8%AE%A9markdown%E4%B8%AD%E5%85%AC%E5%BC%8F%E5%9C%A8hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%98%BE%E7%A4%BA/" class="post-title-link" itemprop="url">如何让markdown中公式在hexo博客中显示</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-04-18 22:58:02 / 修改时间：23:15:33" itemprop="dateCreated datePublished" datetime="2022-04-18T22:58:02+08:00">2022-04-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/hexo/" itemprop="url" rel="index"><span itemprop="name">hexo</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>主要参考了下面这篇帖子：</p>
<p><a
target="_blank" rel="noopener" href="https://dog.wtf/tech/making-hexo-next-theme-latex-math-equation-supported/">让
Hexo Next (v8.0.0) 支持 LaTeX 数学公式</a></p>
<p>步骤如下：</p>
<ol type="1">
<li>安装<a
target="_blank" rel="noopener" href="https://pandoc.org/installing.html">pandoc</a>，并配置config.yml文件。</li>
</ol>
<p>由于我是win10系统，直接下载了zip文件，并解压到D盘（解压位置可任意）。然后在博客的根目录下的_config.yml文件最后面加上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pandoc:</span><br><span class="line">  pandoc_path: D:/pandoc-2.18-windows-x86_64/pandoc-2.18/pandoc.exe</span><br></pre></td></tr></table></figure>
<p>上面的绝对路径就是解压出来的pandoc.exe文件的路径，一定需要加到配置文件里，不然会找不到而报错。</p>
<ol start="2" type="1">
<li>更换默认渲染引擎</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm un hexo-renderer-marked</span><br><span class="line">npm i hexo-renderer-pandoc</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>修改next主题配置文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">math:</span><br><span class="line">  # Default (true) will load mathjax / katex script on demand.</span><br><span class="line">  # That is it only render those page which has `mathjax: true` in Front-matter.</span><br><span class="line">  # If you set it to false, it will load mathjax / katex srcipt EVERY PAGE.</span><br><span class="line">  per_page: true</span><br><span class="line"></span><br><span class="line">  # hexo-renderer-pandoc (or hexo-renderer-kramed) required for full MathJax support.</span><br><span class="line">  mathjax:</span><br><span class="line">    enable: true</span><br><span class="line">    # See: https://mhchem.github.io/MathJax-mhchem/</span><br><span class="line">    mhchem: false</span><br><span class="line"></span><br><span class="line">  # hexo-renderer-markdown-it-plus (or hexo-renderer-markdown-it with markdown-it-katex plugin) required for full Katex support.</span><br><span class="line">  katex:</span><br><span class="line">    enable: false</span><br><span class="line">    # See: https://github.com/KaTeX/KaTeX/tree/master/contrib/copy-tex</span><br><span class="line">    copy_tex: false</span><br></pre></td></tr></table></figure>
<p>需要注意的点：</p>
<ul>
<li>mathjax和katex只能有一个enable，我选择mathjax，相比katex，mathjax更重量级，但对LaTeX支持更好。</li>
<li>per_page即可以设置为true，也可以设置为false。设置为true的含义是，需要人为在博文最前面的格式控制（title那一栏）中添加上mathjax:
true，对指定的博文进行渲染。false表示对所有博文进行渲染，所以无需添加额外的东西了。这里我为了效率考虑，选择true，只不过如果后面写的博文需要渲染，则必须手动添加mathjax:
true。</li>
</ul>
<p>到这里就可以开心地让博文显示LaTeX公式了。</p>
<p>最后提一个编写公式需要注意的地方，行内公式的内容和$符号之间不要有空格，不然可能出现typora能显示，hexo博文显示错误的问题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fanyingjie11.github.io/2022/04/18/%E7%89%9B%E9%A1%BF%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F.png">
      <meta itemprop="name" content="Yingjie Fan">
      <meta itemprop="description" content="飞得比别人高">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="夏天不热">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/18/%E7%89%9B%E9%A1%BF%E6%B3%95/" class="post-title-link" itemprop="url">牛顿迭代法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-04-18 20:34:19 / 修改时间：22:33:46" itemprop="dateCreated datePublished" datetime="2022-04-18T20:34:19+08:00">2022-04-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">数学</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="牛顿迭代法">牛顿迭代法</h1>
<p>在阅读SICP时，在1.1.7节提到了牛顿迭代法，之前的研究生课程《工程优化》中学过，然而很快就忘了，这里旧事重提一下。</p>
<p>牛顿迭代法属于一种一维搜索算法，可以用来求函数<span
class="math inline">\(f(x)\)</span>的零点的近似值，原理如下：</p>
<p>根据<span class="math inline">\(f(x)\)</span>在<span
class="math inline">\({x_n}\)</span>处的一阶泰勒展开式： <span
class="math display">\[
\begin{equation}
f(x) = f\left( {x_n} \right) + f&#39;({x_n})(x - {x_n})
\end{equation}
\]</span></p>
<p>将上式看做<span
class="math inline">\(f(x)\)</span>的近似，那么令<span
class="math inline">\(f(x)=0\)</span>，我们有 $$ 
\begin{equation}
x = {x_n} - \frac{{f({x_n})}}{{f'({x_n})}}
\end{equation}
$$ 
这就是下一轮迭代的新位置，即<span class="math inline">\({x_{n +
1}}\)</span>的值。利用上面的公式，一直迭代到满足条件为止。</p>
<p>迭代的终止条件是很重要的，考虑到计算机的位数限制和舍入误差，一般根据两次相继迭代的结果，计算相对误差，让该误差小于特定值。</p>
<p><img
src="/2022/04/18/%E7%89%9B%E9%A1%BF%E6%B3%95/image-20220418210146454.png" /></p>
<p><img
src="/2022/04/18/%E7%89%9B%E9%A1%BF%E6%B3%95/image-20220418210212254.png" /></p>
<p>牛顿迭代法的几何含义是，用线性逼近曲线。具体可以参考下面这篇文章。</p>
<p><a
target="_blank" rel="noopener" href="https://www.zhihu.com/question/20690553">如何通俗易懂地讲解牛顿迭代法求开方（数值分析）？</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fanyingjie11.github.io/2022/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E8%A7%A3%E9%87%8A%20%E7%AC%AC%E4%B8%80%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F.png">
      <meta itemprop="name" content="Yingjie Fan">
      <meta itemprop="description" content="飞得比别人高">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="夏天不热">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E8%A7%A3%E9%87%8A%20%E7%AC%AC%E4%B8%80%E7%AB%A0/" class="post-title-link" itemprop="url">《计算机程序的构造和解释》书籍阅读</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-04-18 10:10:37 / 修改时间：23:12:42" itemprop="dateCreated datePublished" datetime="2022-04-18T10:10:37+08:00">2022-04-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">程序设计</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近开始读《计算机程序的构造和解释》，英文名是《structure and
interpretation of computer
programs》，简称SICP。囫囵吞枣地读，花了一个周末将前面一二章的内容大致扫了一遍，练习题基本没做。现在想写一个笔记之类的东西，边读边记录自己的收获。</p>
<p>这本书在我看来是比较基础的，但是又是高屋建瓴并且具有一定难度的。说它基础是因为，本书不涉及现代的高级语言，例如C++、JAVA之类的程序，相反，采用了一个早期语言Lisp。但是这本书又全然不是关于Lisp语言特性的描述，而是讲一个更高层次的东西，关于语言的设计和表达能力的东西。我相信这些东西既是基础的，同时又很抽象，将本书的哲学和方法论应用到别的编程语言是有很大价值的。</p>
<h1 id="过程抽象">过程抽象</h1>
<p>本章主要围绕过程这一名词展开，讲了程序设计的基础知识，Lisp的基本语法，过程的表达能力，如何对过程进行抽象，高阶过程的意义等等。采用Lisp这门语言的理由如下：</p>
<blockquote>
<p>正如我们将要看到的，Lisp可以将过程作为数据进行处理的灵活性，使它成为探索这些技术的最方便的现存语言之一</p>
</blockquote>
<h2 id="程序设计的基本元素">程序设计的基本元素</h2>
<p>语言不仅是命令计算机执行的命令，也是一个容纳我们组织计算过程思想的容器。为了将简单的认知组合起来，形成更复杂的认知，每种语言都提供了三种机制：</p>
<ul>
<li>基本表达式</li>
<li>组合的方法</li>
<li>抽象的方法</li>
</ul>
<p>基本表达式就是语言最基础的表示简单认知的东西，组合的方法能够将简单的认知组合成较复杂的认知，而抽象的方法能够将组合在一起的东西作为一个整体去认知。</p>
<h3 id="表达式">表达式</h3>
<p>简单讲了一下和Lisp解释器的交互，前缀表示和美观打印。</p>
<h3 id="命名和环境">命名和环境</h3>
<p>就讲了一个<code>define</code>，可以将名称和一个复杂组合式相关联，这是最简单的抽象方法。</p>
<p>而为了维护这样一种对象和名称的关联，解释器需要维护某种存储能力，这种存储被称为<em>环境</em>。</p>
<h3 id="组合式求值">组合式求值</h3>
<p>组合式的求值过程是递归的：</p>
<ol type="1">
<li>求该组合的各个子表达式。</li>
<li>将最左边的子表达式的过程应用于相应的实际参数（也就是其他子表达式的值）。</li>
</ol>
<p>可以把这种递归计算看成一种树形结构，求值的过程就是从叶子到根的<em>树形累积</em>。</p>
<p>这种递归会一直持续，直到遇见一个基本表达式，处理这些基本表达式的规则就是：</p>
<ol type="1">
<li>数的值就是它们所表示的数值。</li>
<li>其他名字的值就是环境中能完成相应操作的机器指令序列。</li>
</ol>
<p>这里又提到了环境，环境扮演的角色是，用于确定表达式中各个符号的意义，为求值过程提供一种上下文。</p>
<p>除了上述一般性的求值规则外，还有一些特殊形式，例如define就是一例。</p>
<h3 id="复合过程">复合过程</h3>
<p>这里有一个名词上的区分，将加减乘除这些解释器自带的过程称为<em>基本过程</em>，将程序中定义的过程称为<em>复合过程</em>。过程其实就是函数，也是用define去定义。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(define (&lt;name&gt; &lt;paramenters&gt;) &lt;body&gt;)</span><br></pre></td></tr></table></figure>
<p>可以用过程去构造另一个过程。</p>
<h3 id="过程的应用代换模型">过程的应用代换模型</h3>
<p>主要讲了两种代换方式，应用序和正则序。正则序是先代换，直到全部是基本符号之后，再计算。应用序相反，是先计算参数的值，再进行代换。</p>
<h3 id="条件表达式和谓词">条件表达式和谓词</h3>
<p>术语<em>谓词</em>指那些返回真或假的过程。条件表达式cond：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(cond (&lt;p1&gt; &lt;e1&gt;)</span><br><span class="line">	  (&lt;p2&gt; &lt;e2&gt;)</span><br><span class="line">	  ......</span><br><span class="line">	  (&lt;pn&gt; &lt;en&gt;)</span><br></pre></td></tr></table></figure>
<p>其结果是从上往下，遇到的第一个为真的p所对应的e值。</p>
<p>最后一个(<pn> <en>)可以用（else e）。</p>
<p>if表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(if &lt;predicate&gt;&lt;consequent&gt;&lt;alternative&gt;)</span><br></pre></td></tr></table></figure>
<p>结果二选一。</p>
<p>除了基本谓词&gt;&lt;=，还有复合的表达式，and、or、not等。</p>
<h3 id="实例采用牛顿法求平方根">实例：采用牛顿法求平方根</h3>
<p>数学函数，像<span class="math inline">\(y = {x^2}\)</span>
是说明性的，为了求它的根，计算机程序需要行动性的描述。计算机求平方根最常用的方法是牛顿迭代。</p>
<p>如果对<span
class="math inline">\(x\)</span>的平方根有了一个猜测值<span
class="math inline">\(y\)</span>，那么就能够通过<span
class="math inline">\(y\)</span>和<span
class="math inline">\(x/y\)</span>的平均值进行下一次逼近。牛顿迭代法准备单独细讲。</p>
<h3 id="过程作为黑箱抽象">过程作为黑箱抽象</h3>
<p>过程可以分解为多个子过程。一个求平方的过程square，对于使用者而言是一个黑箱，或者说抽象过程。使用者只考虑这个过程返回的是一个数的平方，而不需要弄清楚它是如何实现的。</p>
<p>为了让过程用户不用关心过程的实现细节，一个重要的点就是过程的意义不依赖于形参的名字。过程的形式参数必须是局部的（只在过程内部起作用）。我们成过程的形参为<em>约束变量</em>，约束形参的表达式集合就是形参的作用域。</p>
<p>为了让过程局部化，可以允许一个过程带有一些内部定义（define里面套define）。这种嵌套的定义称为块结构。</p>
<h2 id="过程及其产生的计算">过程及其产生的计算</h2>
<h3 id="线性递归和迭代">线性递归和迭代</h3>
<p>文中基于<span
class="math inline">\(n!\)</span>的计算方式，给了两种算法，一个是线性递归，一个迭代计算。</p>
<p>注意不要搞混了<em>递归计算过程</em>和<em>递归过程</em>的概念，如果一个过程内部调用了自身，那它就是一个递归过程，然而计算过程却不一定是递归的。递归过程的计算过程可能是迭代的。</p>
<p>注意<em>迭代的计算过程</em>和<em>递归的计算过程</em>的区别。迭代的计算过程只需要有限的几个变量来保持系统当前的计算状态，而递归的计算过程中，解释器需要维护一个将要执行的操作的轨迹。</p>
<p>文中提到，有些语言对于任何递归过程的解释，都需要消耗与过程调用数目成正比的存储量，为了在这些语言中实现迭代，就必须采用特殊的循环结构，例如for、while。而Scheme的实现则没有这一缺陷，总能在常量空间中执行迭代计算过程，即使它是一个递归过程，具有这一特性的实现称为<strong>尾递归</strong>的。</p>
<h3 id="树形递归">树形递归</h3>
<p>文中给出了计算斐波拉契数的简单树形递归版本和一个迭代版本。而后给出一个实例，换零钱的方式统计，并给出了一个树形递归的版本，要读者给出一个迭代的版本。其实这个问题</p>
<h3 id="增长的阶">增长的阶</h3>
<p>也就是评估算法计算复杂度那一套。</p>
<h3 id="求幂">求幂</h3>
<p>计算<span
class="math inline">\({b^n}\)</span>可以线性的递归也可以采用线性的迭代计算，而更快速的计算方式是对数级的。</p>
<p>练习1.19给出一个对数级的计算斐波拉契数的算法（貌似leetcode上面做过）。</p>
<h3 id="最大公约数">最大公约数</h3>
<p>欧几里得算法，算法的阶是对数级。</p>
<h3 id="素数检测">素数检测</h3>
<p>检查整数<span
class="math inline">\(n\)</span>是否是素数有两种算法，第一种具有<span
class="math inline">\(O(\sqrt n )\)</span>的阶，第二种具有<span
class="math inline">\(O(\log n)\)</span>的阶。</p>
<p>第一种算法是，从<span
class="math inline">\(2\)</span>开始一步步直到不超过<span
class="math inline">\(\sqrt n\)</span>的整数，一个个尝试能够整除<span
class="math inline">\(n\)</span>。</p>
<p>第二种算法是，利用费马小定理。</p>
<p><strong>费马小定理</strong>：如果<span
class="math inline">\(n\)</span>是一个素数，<span
class="math inline">\(a\)</span>是小于<span
class="math inline">\(n\)</span>的任意正整数，那么<span
class="math inline">\(a\)</span>的<span
class="math inline">\(n\)</span>次方与<span
class="math inline">\(a\)</span>模<span
class="math inline">\(n\)</span>同余。</p>
<p>这是一种概率算法，如果不能通过费马检查，那么可以确定<span
class="math inline">\(n\)</span>一定不是素数，如果能通过费马检查，则我们更加相信<span
class="math inline">\(n\)</span>是素数。</p>
<h2 id="用高阶函数做抽象">用高阶函数做抽象</h2>
<h3 id="过程作为参数">过程作为参数</h3>
<p>操作过程的过程称为高阶过程，高阶过程是强有力的抽象机制，极大增强了语言的表达能力。</p>
<p>从数学上的求和公式出发，解释了抽象模式的存在，和求和符号一样，可以建立一个公共模式，用来求某一类问题。</p>
<p>同时还给出了一个用公共模式sum进行积分的近视计算的例子。</p>
<h3 id="用lambda构造过程">用lambda构造过程</h3>
<p>不用显示定义一个过程。通过引入lambda特殊形式来完成这一过程，而无需定义辅助过程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lambda (&lt;parameters&gt;) &lt;body&gt;)</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fanyingjie11.github.io/2022/04/14/typora%E5%92%8Chexo%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%E7%9A%84%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F.png">
      <meta itemprop="name" content="Yingjie Fan">
      <meta itemprop="description" content="飞得比别人高">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="夏天不热">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/14/typora%E5%92%8Chexo%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%E7%9A%84%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">typora和hexo图片显示的问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-14 11:11:41" itemprop="dateCreated datePublished" datetime="2022-04-14T11:11:41+08:00">2022-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-29 08:35:44" itemprop="dateModified" datetime="2022-04-29T08:35:44+08:00">2022-04-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/hexo/" itemprop="url" rel="index"><span itemprop="name">hexo</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="问题发现">问题发现</h1>
<p>最近自己捣鼓了一下博客，按照网上教程一步步来，把博客弄好了，迫不及待地发布了一篇文章，结果发现图片无法显示。上网一查发现是由于hexo和markdown的图片引用格式不一致。于是又Google了半天，终于把问题给比较好地解决了。</p>
<h1 id="解决方案">解决方案</h1>
<p>首先，对typora的设置进行调整，让图片自动保存到相同位置的同名文件夹下。</p>
<p><img
src="/2022/04/14/typora%E5%92%8Chexo%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%E7%9A%84%E9%97%AE%E9%A2%98/image-20220414111729211.png" /></p>
<p>这样，如果我如果在D:\Blog\source\posts目录下建了一个A.md文件，则对应就会在相同目录下出现一个A文件夹，里面保存了A.md中的所有图片。</p>
<p>接下来，需要利用一个插件（hexo-asset-link），首先安装插件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -s hexo-asset-link</span><br></pre></td></tr></table></figure>
<p>设置config.yml文件中的post_asset_folder为true</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure>
<p>然后就是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>完事了，可以发现图片既能在typora中显示，也能在博客中正常显示。</p>
<p>需要注意的问题是，在引用图片时，需要满足格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![XX](A/XXX.png)</span><br></pre></td></tr></table></figure>
<p>也就是说，需要圆括号里面是相对路径，方括号里的内容只是对该图片进行说明。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fanyingjie11.github.io/2022/04/13/GFS%E8%AF%BB%E5%90%8E%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F.png">
      <meta itemprop="name" content="Yingjie Fan">
      <meta itemprop="description" content="飞得比别人高">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="夏天不热">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/13/GFS%E8%AF%BB%E5%90%8E%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">《The Google File System》论文阅读</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-13 21:45:22" itemprop="dateCreated datePublished" datetime="2022-04-13T21:45:22+08:00">2022-04-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-18 23:08:07" itemprop="dateModified" datetime="2022-04-18T23:08:07+08:00">2022-04-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/" itemprop="url" rel="index"><span itemprop="name">分布式存储</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" itemprop="url" rel="index"><span itemprop="name">论文阅读</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言">前言</h1>
<p>GFS是Google内部广泛使用的大规模分布式文件系统，适用于大的分布式数据密集型应用。GFS的设计和之前的分布式文件系统的主要区别在于，设计目标有很多不同：</p>
<ol type="1">
<li>设备失效是常态而不是例外。</li>
<li>从传统标准看，文件通常较大（几GB）。因此IO操作和块大小的设计需要重新考虑。</li>
<li>大多数文件仅append新数据，不会覆盖写旧的数据。一个文件内的随机写基本不存在。一次写入，后面只读，并且是顺序读。所以append成了性能优化的关键，同时，在客户端缓存数据失去了吸引力。</li>
<li>联合设计文件系统API和应用程序对整个系统有好处。</li>
</ol>
<p>GFS在谷歌内部最大的集群有超过一千台机器、上千个磁盘和几百TB的数据，同时被上百个客户端并发访问。</p>
<h1 id="设计总览">设计总览</h1>
<h2 id="一些设计上的前提">一些设计上的前提</h2>
<p>这些设计的前提条件是通过分析谷歌内部的应用工作负载和技术环境得到的：</p>
<ol type="1">
<li>设备失效是常态。</li>
<li>文件通常比较大，100MB、几个GB。也要支持小文件，但不针对性优化。</li>
<li>工作负载有两种读取：一是大的流式读取，通常几百KB、1MB。而是小的随机读取，通常几KB（一般会对小的随机读做排序和批处理）。</li>
<li>写操作通常是大的顺序append。操作大小和读相近。小的随机写也支持，但不优化。</li>
<li>必须对多个客户端并发的append操作提供良好的语义。文件通常用作生产者消费者队列或者多路归并。上百个生产者，同时对一个文件做append。要以最小的同步开销实现原子append。文件后面会被一个消费者读取（GFS能够支持高效的N:1队列）。</li>
<li>高的持续带宽比低时延更重要。应用程序通常注重高速批量处理数据，而不是单个读写请求的响应时间。</li>
</ol>
<h2 id="接口">接口</h2>
<p>GFS没有实现POSIX
接口，文件被目录组织成层级结构，并支持create、delete、open等操作。</p>
<p>重点是，GFS支持低开销的快照snapshot和原子append（record
append）。</p>
<h2 id="总体架构">总体架构</h2>
<figure>
<img
src="/2022/04/13/GFS%E8%AF%BB%E5%90%8E%E7%AC%94%E8%AE%B0/GFS架构图.png"
alt="GFS整体架构图" />
<figcaption aria-hidden="true">GFS整体架构图</figcaption>
</figure>
<p>上图是GFS的整体架构，有几个重要角色，chunkserver、client、master，通常都是运行在Linux上的用户进程。</p>
<p>文件被划分为固定大小的chunk（这个大小很有讲究，后面会说）。每个chunk被一个不可更改且全局唯一的64bit
<em>chunk
handle</em>标识，并在这个chunk被创建的时候赋值。chunkserver将chunk存储为本地的linux文件。读写chunk中的数据需要chunk
handle以及字节范围。为了可靠性，一个chunk被存储多份，在不同的机器上（高可用一章会讲）。</p>
<p>master负者维护所有元数据。包括namespace、访问控制信息、从文件到chunk的映射、chunk的当前位置。同时master也控制系统级的行为，例如chunk租约管理、垃圾回收、chunk迁移。master与chunkserver进行周期性的心跳通信，来下发指令和搜集状态。</p>
<p>client链接到应用程序，提供文件系统API。client与master交互，进行元数据操作，但数据通信直接与chunkserver进行。</p>
<p>client不缓存文件数据（但缓存元数据）。因为client缓存文件没有多大的好处，应用程序的工作数据集非常大，缓存了没用。这样做也消除了缓存一致性的问题。chunkserver不需要缓存文件数据，因为本身Linux的buffer
cache将经常使用的数据放在了内存。</p>
<h2 id="single-master">single master</h2>
<p>使用单个master大大简化了系统设计。然而必须最小化master参与数据读写的程度，使它不成为一个瓶颈。client从来不通过master读写文件数据，而是询问master需要和哪个chunkserver联系。并且client会缓存这个信息一段时间，并在接下来的操作中直接和chunkserver交互。</p>
<p>下面描述一个简单的读数据流程：首先，client将应用程序指定的文件名和字节偏移量翻译成文件中的chunk
index。然后，client发送给master一个请求，包含文件名和chunk
index。master响应以chunk
handle和副本的位置。client缓存这些信息，用文件名和chunk
index当作KEY。然后client发送一个请求给其中一个副本，通常是最近的一个。请求指定了chunk
handle和一个字节范围。读写相同的chunk不需要额外的client-master交互，一直到缓存的信息失效或者文件被重新open。事实上，client和master通信的时候可以多要几个还没有被请求的接下来的chunk的信息，或者master主动多给几个，这样可以节省接下来的client-master交互，并且基本没有额外的开销。</p>
<h2 id="chunk-size">chunk size</h2>
<p>chunk大小是一个设计的关键参数，GFS默认是64MB，远大于典型的文件系统块大小。这样做有几个好处：</p>
<ol type="1">
<li>减少了client-master交互</li>
<li>client更可能在一个给定的chunk上执行一系列操作，这样可以通过和一个固定的chunkServer建立持久TCP连接来降低通信开销。</li>
<li>减少了master的存储开销。</li>
</ol>
<p>缺点是：小文件可能导致热点问题。如果一个小文件只包含例如一个chunk，而同时有很多client想要访问该文件。文中举了一个例子，一个可执行文件写到了GFS的一个chunk里，同时启动上百个机器，每个机器都请求这个文件，导致chunkserver过载了。解决办法是：用高的复制因子存储该文件，并利用批处理程序错开应用启动时间。一个潜在的长期解决方案时，让client在这种情况下可以从别的client读数据。</p>
<h2 id="metadata">metadata</h2>
<p>master存储三种元数据，文件和chunk的namespace、从文件到chunk的映射、chunk副本的位置。三种数据都存放在内存里，同时前面两类数据持久化到硬盘（通过<em>operator
log</em>），并且为了高可用，还要复制到别的机器上。使用log是为了保证master故障的时候防止数据不一致。</p>
<p>master不存chunk的位置。</p>
<h3 id="内存数据结构">内存数据结构</h3>
<p>元数据全部放在内存可以加速master的操作。master需要周期性地扫描它的整个状态，用来进行垃圾回收、加副本、chunk迁移、磁盘空间利用。</p>
<p>不用担心内存不够用。</p>
<h3 id="chunk位置">chunk位置</h3>
<p>master并不持久化chunk的位置，从哲学上讲，只有chunkserver知道它所有的chunk，master持久化了也没用。这样做消除了master和chunkserver同步的问题。</p>
<h3 id="operation-log">operation log</h3>
<p>operation
log是master唯一持久化的东西，不仅是为了持久化，还为并发操作提供时间线。</p>
<p>必须可靠存储operation
log，在持久化之前，修改对用户不可见。只有在本地和远端机器上都做了持久化，才对client进行响应。同时为了加速，master将多个log合并刷盘，这样可以减少对系统吞吐的影响。</p>
<p>master可以通过重放operation
log恢复文件系统的状态。为了最小化启动时间，需要让log尽可能少，这就需要checkpoint。同时，为了加速，本文的checkpoint还有这样一个特性，就是可以直接加载到内存，用来进行namespace的查询，而不需要解析，这又加速了恢复过程，提高了可用性。</p>
<p>为了让checkpoint不影响正常的操作，master转到一个新的log文件上，同时创建单独的线程执行checkpoint，将转换log之前的所有修改都包含进去。</p>
<h3 id="一致性模型">一致性模型</h3>
<h4 id="gfs的保证">GFS的保证</h4>
<p>这一部分感觉是最难懂的，需要结合后面三四章的内容一起看才能完全明白。这里就按照原文简单提一下。</p>
<p>文件的namespace的修改是原子的，这是通过读写锁保证的，后面会介绍。</p>
<p>对于文件本身的数据，按照我的理解，GFS提供的保证其实是比较弱的保证。对于串行没有其他client干扰的write和record
append，GFS保证一致性（这里的一致性的含义是，所有副本保存的数据是相同的），同时还保证defined语义。defined语义按照我的理解是不发生脏写，也就是多个并发执行的写操作不会互相覆盖，client可以在中间读取到某一次写操作的完整更新内容。由于串行执行，没有并发操作，当然满足defined语义了。</p>
<p>如果有并发执行的写操作，对于write而言，不满足defined但满足一致性。而对于record
append而言，不管有没有并发写操作，都是defined的，并且有穿插不一致性（但是基本没有影响），这个和record
append的实现有关，后面会讲。最后，失败的修改肯定是会导致不一致的了。</p>
<figure>
<img
src="/2022/04/13/GFS%E8%AF%BB%E5%90%8E%E7%AC%94%E8%AE%B0/一致性.png"
alt="读写一致性" />
<figcaption aria-hidden="true">读写一致性</figcaption>
</figure>
<p>对于前面提到串行的写操作，GFS通过（a）对所有副本执行相同顺序的修改操作
（b）使用chunk的版本号检测过时的副本（由于chunkserver下线导致修改丢失）
来实现。</p>
<p>过时的副本从不会被包含进一个修改中，也不会在client向master请求的时候，由master响应包含（具体机制后面讲）。后面自动被垃圾回收处理掉。但是由于client会缓存chunk的位置信息，所以有可能读到过时的副本数据。但是这个时间窗口被缓存过期时间和下一次open限制住了。另外由于大多数写操作都是append的，所以这种情况下client读到的只是提前结束的数据而不是过时的数据。当client联系master时，会立即得到新数据的位置。</p>
<h4 id="对应用程序的影响">对应用程序的影响</h4>
<p>GFS的应用程序能够容忍宽松的一致性模型。</p>
<p>实际应用程序基本全是append而非overwriting。典型的场景是，一个写者生成数据从头到尾。写者写完之后，给文件一个永久性的名称，或者周期性地checkpoint成功写入了多少。读者仅处理最后一次checkpoint之前的文件（处于defined状态）。</p>
<p>另一个典型场景是，多个写者同时append一个文件。根据record
append的语义，读者需要处理padding和重复数据：每个record都包含额外的信息例如校验和，所以读者能够区分和忽略掉额外的padding以及record的片段。如果读者不能忍受重复的record，可以过滤掉它们，通过唯一性ID。</p>
<h1 id="系统交互">系统交互</h1>
<p>在最小化master参与操作的前提下进行的设计。</p>
<h2 id="租约和修改顺序">租约和修改顺序</h2>
<p>租约的设计主要是为了最小化master的开销。master给某个chunk一个租约，这个chunk称为主副本（primary）。当每个修改（mutation）操作执行时，主副本选择对这个chunk执行的所有操作的顺序，所有副本都按相同顺序执行修改操作。因此，全局的修改顺序被master的租约顺序和主副本的执行顺序确定。</p>
<p>租约最开始有60s的超时，只要这个chunk被修改，主副本能够无限次地请求延长租约。这些请求和响应的包含在心跳中。</p>
<p>master即使失去了和主副本的通信，也能够在一个租约到期后，安全地将租约赋给别的副本。</p>
<figure>
<img
src="/2022/04/13/GFS%E8%AF%BB%E5%90%8E%E7%AC%94%E8%AE%B0/写控制流和数据流.png"
alt="写操作的控制流和数据流" />
<figcaption aria-hidden="true">写操作的控制流和数据流</figcaption>
</figure>
<p>下面解释上图中写操作流程。</p>
<ol type="1">
<li>client向master询问哪个chunkserver拥有当前chunk的租约，以及其余从副本的位置。</li>
<li>master响应主副本的标识和从副本的位置。client缓存这些信息，直到主副本不可达或响应以租约过期。</li>
<li>client发送数据给所有副本。这一步的优化后面有详细解释。</li>
<li>一旦所有副本确认收到数据，client向主副本发起写请求。主副本将收到的所有修改（可能来自不同的client）编号，并应用到本地状态。</li>
<li>主副本将写请求发送给从副本，每个从副本应用与主副本相同顺序的修改。</li>
<li>从副本告知主副本已完成修改。</li>
<li>主副本响应client。如果发生错误，例如主副本或主副本和从副本的子集出错，client将认为修改失败，并进行第三步到第七步的重试。</li>
</ol>
<p>如果写操作的数据超出一个chunk的大小，则GFS的client的代码将其分为多个写操作进行，但是这些写操作可能和别的client的写操作有交叉，因此可能被覆盖掉。因此，共享的文件区域可能最终包含不同client的片段，尽管所有副本的数据是相同的（一致的）。</p>
<h2 id="数据流">数据流</h2>
<p>通过解耦数据流和控制流，有效地使用网络。</p>
<ol type="1">
<li><p>为了充分利用每台机器的网络带宽，采用链式而非其他方式（例如树型）传输。因此，每台机器的全部出站带宽都用于尽可能快地传输数据，而不是在多个接收者之间分配。</p></li>
<li><p>为了避免网络瓶颈和高延迟，每台机器向前传送数据给距离最近的未收到数据的机器。例如，假设有四台机器s1到s4，client先发送数据给离他最近的机器s1，然后s1发送数据给离他最近的机器s2。。。</p></li>
<li><p>通过pipeline的方式传送数据，最小化延时。文中给了具体例子。</p></li>
</ol>
<h2 id="record-append">record append</h2>
<p>record
append类似于Linux中的O_APPEND。论文里面没有给出具体的实现方式，但是解释的确很详细。</p>
<p>步骤如下：从图2的第四步开始，client发送请求给主副本，主副本查看是否在append之后会超出一个chunk的最大大小，如果超出，就将当前chunk进行pad到最大大小，然后通知从副本一样这么做，最后告诉client对下一个chunk进行重试（append的数据量也是受限的）。如果没有超过大小限制，则主副本将数据append到本地，并告诉从副本写相同的数据到相同的偏移量处，最后响应client。</p>
<p>如果一个record
append失败了，client会进行重试，因此相同chunk的多个副本可能包含不一致的数据，例如相同record的重复数据。GFS不保证所有副本的数据完全相同，只保证数据至少被原子地成功写入一次。但这对读取没太大影响。</p>
<h2 id="快照">快照</h2>
<p>为了不影响后续的写操作，采用了写时复制技术。感觉也没什么好讲的。</p>
<h1 id="master相关">master相关</h1>
<h2 id="namespace管理和锁">namespace管理和锁</h2>
<p>读写锁，论文讲的也很简单。只需提一点，为了防止死锁，有一个全局的加锁顺序，首先按照namespace树的层级结构加锁，其次按照字典顺序加锁。</p>
<h2 id="副本放置">副本放置</h2>
<p>目标是提升可用性可靠性以及网络带宽的利用率。由于整个架构是跨机架的，机架内部机器的聚合带宽要比跨机架高。一般会放一个副本到别的机架的机器上。这样提供了跨机架的读的聚合带宽，但同时增加了写的跨机架的开销，这是一个tradeoff。</p>
<h2
id="创建re-replicationrebalancing">创建、re-replication、rebalancing</h2>
<p>这三个操作基本目标都类似，需要提高磁盘利用率，平衡负载，保证可靠性和可用性，并且还需要限制带宽的使用，避免影响应用程序。具体影响因素直接看论文。</p>
<h2 id="垃圾回收">垃圾回收</h2>
<p>GFS采用惰性垃圾回收机制。这比eager deletion的优势在于：</p>
<ol type="1">
<li><p>提供了一个统一和独立的方式，来清除不知道是否有用的chunk。简单并且可靠。</p></li>
<li><blockquote>
<p>其次，它将存储回收合并到 master
的常规后台活动中，例如定期扫描命名空间和与 chunkserver 的握手。
因此，它是分批完成的，成本是摊销的。</p>
</blockquote></li>
<li><p>防止意外的，不可逆的删除。</p></li>
</ol>
<p>惰性删除的缺点是：掩盖了某些应用优化存储开销的努力。解决办法是，如果已经删除的文件被再次明确删除，就回收存储空间，同时用户也可以指定不同而回收策略，针对namespace的不同部分。</p>
<h2 id="过时副本检测">过时副本检测</h2>
<p>GFS利用版本号（chunk version number ）区分过时的副本。</p>
<p>master和所有的副本都将版本号持久化，在每次master赋予一个新的租约的时候，就增加版本号。如果某个副本因为在此时变得不可用，则它的版本号不会增加。master将在chunkserver重启时检测到这个chunkserver有过时的副本（因为chunkserver在重启的时候会向master报告它的chunk集合以及这些chunk相关的版本号）。</p>
<p>对于过时的副本，master使用垃圾回收机制，在此之前它不会告诉client过时副本的存在。另外，在master与client和chunkserver通信过程中会带着chunk的版本号，这样client和chunkserver可以进行验证。</p>
<h1 id="容错和检测">容错和检测</h1>
<p>论文中提到，设计系统的最大挑战是面对故障。</p>
<h2 id="ha">HA</h2>
<p>使用两个策略达到高可用：快速恢复和副本机制</p>
<h3 id="快速恢复">快速恢复</h3>
<p>master和chunkserver都设计成可以在秒级恢复，事实上并不区分正常的终止和异常的终止，可以直接kill来结束进程。</p>
<h3 id="chunk复制">chunk复制</h3>
<p>没什么可说的，文中提到他们在想办法引入纠删码。</p>
<h3 id="master复制">master复制</h3>
<p>为了高可用，master的状态也要复制，它的operation
log和checkpoint被复制到多台机器。只有当所有master的副本都将log刷盘，才会认为一个修改提交了。</p>
<p>论文中提到“shadow”master，我认为这就是复制了master状态的机器，“shadow”master可以提高可用性，就算master故障了，“shadow”master也可以提供只读服务，所以增强了读可用。但是毕竟“shadow”master不是真正的master，会有一定得延迟（文中提到只有元数据读取会有短的延时）。</p>
<p>“shadow”master要读取operation
log并应用相同的修改到本地。它也在开始时和chunkserver通信获取chunk的位置信息，后面需要依赖于master更新这些信息。</p>
<h2 id="数据完整性">数据完整性</h2>
<p>直接比较不同副本的数据来验证数据完整性是不现实的，所以每个chunkserver使用校验和独自验证数据完整性。</p>
<p>每个chunk分为64kB的block，每个block都有一个32bit的校验和。和元数据一样，校验和保存在内存中，并被持久化到磁盘。</p>
<p>为了防止错误数据的传播，在chunkserver响应client或者别的chunkserver的请求时，会提前使用校验和进行检查。当发现错误时，chunkserver向请求者报告错误，并通知master，这样请求者可以去读取别的副本，master会克隆该chunk，在克隆后master会通知chunkserver删除错误数据。</p>
<p>校验和对读性能的影响很小，同时文中提到对于append操作，着重优化了校验和的计算。</p>
<p>在空闲的时候，chunkserver会用校验和检查那些不活跃的chunk。</p>
<h2 id="诊断日志">诊断日志</h2>
<p>诊断日志对分析系统极其重要，并且文中提到由于诊断日志是顺序、异步写操作，所以对性能影响很小。</p>
<h1 id="性能分析">性能分析</h1>
<p>忽略掉，这块确实很难讲2333</p>
<h1 id="经验">经验</h1>
<p>文中就简单提了几个关于Linux内核的问题。</p>
<p>暂时先写这么多吧。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yingjie Fan"
      src="/images/%E5%A4%B4%E5%83%8F.png">
  <p class="site-author-name" itemprop="name">Yingjie Fan</p>
  <div class="site-description" itemprop="description">飞得比别人高</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fanyingjie11" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fanyingjie11" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/yjfan_1@foxmail.com" title="E-Mail → yjfan_1@foxmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://fanyingjie11.github.io/2022/04/13/GFS%E8%AF%BB%E5%90%8E%E7%AC%94%E8%AE%B0/" title="https:&#x2F;&#x2F;fanyingjie11.github.io&#x2F;2022&#x2F;04&#x2F;13&#x2F;GFS%E8%AF%BB%E5%90%8E%E7%AC%94%E8%AE%B0&#x2F;">GFS笔记</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; Wed Apr 13 2022 08:00:00 GMT+0800 (中国标准时间) – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yingjie Fan</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


</body>

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
</html>
