<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fanyingjie11.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="飞得比别人高">
<meta property="og:type" content="website">
<meta property="og:title" content="夏天不热">
<meta property="og:url" content="https://fanyingjie11.github.io/index.html">
<meta property="og:site_name" content="夏天不热">
<meta property="og:description" content="飞得比别人高">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Yingjie Fan">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://fanyingjie11.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>夏天不热</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">夏天不热</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fanyingjie11.github.io/2022/05/17/MEC%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F.png">
      <meta itemprop="name" content="Yingjie Fan">
      <meta itemprop="description" content="飞得比别人高">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="夏天不热">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/17/MEC%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/" class="post-title-link" itemprop="url">《More Effective C++》阅读（三）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-05-17 15:01:54 / 修改时间：21:15:36" itemprop="dateCreated datePublished" datetime="2022-05-17T15:01:54+08:00">2022-05-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">程序设计</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="异常">异常</h1>
<p>为什么C++中需要添加异常，而不和C语言一样使用“设定状态变量”的方式，或返回错误码的方式，因为无法保证函数的调用者一定会检查，如果不进行检查，那么错误可能一直继续下去。而如果函数抛出异常而未被捕捉，则程序会被中止。</p>
<p>本章用来帮助写一个异常安全的程序。</p>
<h2 id="利用析构函数避免资源泄露">利用析构函数避免资源泄露</h2>
<p>本节主要观点是以对象来管理资源，这也是智能指针要做的事情，普通的指针在面对异常情况时很容易发生资源泄露，尽管可以用try
catch语句来控制异常行为。</p>
<p>智能指针的观点也可以推而广之，如对象有必须释放资源，则依赖对象的析构函数释放。</p>
<p>如果异常出现在获取资源的过程中，或析构过程中怎么办，后面两节分别论述构造函数和析构函数中的异常处理。</p>
<h2 id="在构造函数内阻止资源泄露">在构造函数内阻止资源泄露</h2>
<p>构造函数可以抛出异常，但要注意资源泄露的问题。如果对象有指针成员，尤其需要注意。</p>
<p>文中给出三种办法来应对。</p>
<p>方案一：在构造函数内使用try
catch语句来控制异常，delete掉前面已经构造好的部分。</p>
<p>方案二：考虑到指针可能是常量，或者说必须是在构造函数初始值列表中进行初始化，那么就不能使用try
catch了。这个时候可以单独将每个指针单独用额外函数进行初始化，在额外函数内可以使用try
catch语句，但这样做很复杂，本应该由构造函数完成的动作现在分布于多个函数中。</p>
<p>方案三：智能指针，不适用普通指针。</p>
<h2 id="禁止异常流出析构函数之外">禁止异常流出析构函数之外</h2>
<p>析构函数会在两种情况下被调用，一种是对象正常状态下被销毁，二是被异常处理机制销毁。当第二种情况发生时，如果析构函数中又抛出异常，则程序会调用terminate函数，直接中止。</p>
<p>避免异常流出析构函数有两个好处，一是防止在异常处理中程序中止，二是可以协助确保析构函数完成应该完成的事情（例如一些清理工作）。</p>
<h2 id="抛出异常与函数参数传递的差异">抛出异常与函数参数传递的差异</h2>
<p><strong>第一点是参数传递的做法不同</strong></p>
<p>抛出异常必然会导致复制行为，即生成一个临时对象，这个对象是抛出对象的副本（catch到的不能是已经销毁的对象）。</p>
<p>需要注意的是，该临时对象一定是抛出对象的静态类型。</p>
<p>不论是以by value还是以by
reference的方式捕捉异常，都必然会发生拷贝构造，所以抛出异常会比函数参数传递更慢。</p>
<p>注意<code>throw;</code>和<code>throw e;</code>的区别，前者抛出原先捕获的异常，而后者重新抛出一个异常对象。</p>
<p>通常使用<code>throw;</code>比较有效率。</p>
<p>另一个不同是，捕捉异常可以<code>by reference</code>或<code>by reference-to-const</code>方式，都可以绑定到临时对象，而函数参数传递则不行。</p>
<p><strong>第二点是类型匹配规则不同</strong></p>
<p>异常与catch子句的匹配中，不含通常语句的隐式类型转化，可以发生的类型转化有两种，一是继承体系中的类型转换。二是有型指针转换为void无型指针。</p>
<p>需要注意catch匹配是顺序的而非最佳匹配。所以捕捉父类的catch要放在捕捉子类的catch后面。</p>
<h2 id="以by-reference方式捕捉异常">以by reference方式捕捉异常</h2>
<p>以by reference方式捕捉异常，避免了by
value方式可能发生slice的问题，以及by
pointer方式可能发生内存泄露问题。</p>
<h2
id="明智运用异常规范exception-specifications">明智运用异常规范（exception
specifications）</h2>
<p>exception
specifications在C++11中被弃用，并在C++17中被删除，不使用就行了。因为exception
specifications可能导致程序意外中止。</p>
<h2 id="了解异常处理成本">了解异常处理成本</h2>
<p>总结一下就是，只有在必要的时候才使用try或抛异常。抛异常应该是非常少见的，根据28法则，对程序性能影响不大。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fanyingjie11.github.io/2022/05/12/MEC%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F.png">
      <meta itemprop="name" content="Yingjie Fan">
      <meta itemprop="description" content="飞得比别人高">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="夏天不热">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/12/MEC%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/" class="post-title-link" itemprop="url">《More Effective C++》阅读（二）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-05-12 15:18:11 / 修改时间：17:39:03" itemprop="dateCreated datePublished" datetime="2022-05-12T15:18:11+08:00">2022-05-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">程序设计</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="操作符">操作符</h1>
<h2 id="对定制的类型转换函数保持警觉">对定制的类型转换函数保持警觉</h2>
<p>C++延续了C语言的一些东西，例如doube可以直接转换成int，short可以转换为double，但是对于自己定义的类，需要控制这种隐式类型转换。</p>
<p>两种函数允许隐式类型转换，一个是单参数构造函数，一个是隐式类型转换操作符。</p>
<p>单参数构造函数指的是能够以单一自变量调用的构造函数。</p>
<p>隐式类型转换操作符就是operator (type) ()，没有返回值。</p>
<p>文中主要讲了单参数构造函数的害处，隐式类型转换操作符直接不去定义就可以避免了。</p>
<p>隐式类型转换的主要缺点是：可能在不知情的情况下发生转换。</p>
<p>可以用一个显示的函数来代替隐式转换。例如string不能隐式转换成C风格的char*，而是提供一个c_str()函数。</p>
<p>两种做法可以保证既能提供单参数构造函数，又能避免隐式类型转换。</p>
<p>一种是简单的加上explicit关键字。</p>
<p>二是使用代理类。这其中利用了一条类型转换的规则，即一个类型转换中不可以包含一个以上的用户定制的转换行为。</p>
<h2 id="区别前置和后置的--">区别前置和后置的++--</h2>
<p>前置和后置的++操作可以重载，但为了区分这两者，后置的++重载要带一个int形参，编译器给其填充0。</p>
<p>需要注意，前置的++返回引用，而后置的++返回const对象。</p>
<p>为什么后置++返回const对象，首先后置++需要返回一个临时的旧值，所以得返回一个对象，而加上const就限制了<code>x++++</code>这种用法的出现，保证和内置的int的行为一致。</p>
<p>由于后置的++返回了一个临时对象，所以需要构造和析构成本，通常用户定义的类，推荐使用前置++。</p>
<p>为了方便代码维护，通常后置++以前置++为其实现基础。</p>
<h2 id="千万不要重载和操作符">千万不要重载&amp;&amp;、||和,操作符</h2>
<p>原因很简单，这三个运算符都有自左向右的表达式计算顺序。而自己重载这些操作符，在调用过程中，实际上是函数调用，而函数调用中，各个参数的求值顺序是没有保证的。</p>
<p>,逗号运算符在for循环中可以出现，逗号左侧的表达式在右侧表达式之前求值，整个表达式的值是右侧表达式的返回值。</p>
<h2
id="了解各种不同意义的new和delete">了解各种不同意义的new和delete</h2>
<p>首先需要区分new operator和operator new，new
operator包含两步，分配内存和构造对象，其中，分配内存这步是调用了operator
new，所以我们可以重载operator new来控制内存分配。</p>
<p>注意placement
new，可以在指定的内存上构造对象。对共享内存和mmap很有用。</p>
<p>placement new是标准程序库的一部分，使用时需包含new头文件。</p>
<p>总结：new operator直接在堆上分配内存并构造对象，operator
new只分配对象，如果希望决定内存分配的方式，需要重载operator
new，并使用new operator，它会自动调用operator new。placement
new在给定内存上构造对象。</p>
<p>delete operator和operator delete的关系与new operator和operator
new的关系类似，可以重载operator delete。注意placement
new得到的对象，应该避免使用delete
operator，因为对象的内存不一定是由operator new分配的。</p>
<p>数组：可以重载operator new[]和operator delete[]，没有细讲。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fanyingjie11.github.io/2022/05/09/MIT_6_824_lab1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F.png">
      <meta itemprop="name" content="Yingjie Fan">
      <meta itemprop="description" content="飞得比别人高">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="夏天不热">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/09/MIT_6_824_lab1/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-05-09 21:55:12 / 修改时间：22:16:09" itemprop="dateCreated datePublished" datetime="2022-05-09T21:55:12+08:00">2022-05-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>规则：</p>
<ol type="1">
<li>map阶段需要将中间键值对划分到<code>nRduce</code>个桶，提供给reduce
task.</li>
<li>worker需要将第x个reduce
task的输出保存在文件<code>mr-out-X</code>中。</li>
<li>输出文件<code>mr-out-X</code>中每一行对应一个reduce函数的输出。注意输出格式。</li>
<li>能够修改的文件有<code>mr/worker.go</code>、<code>mr/master.go</code>、<code>mr/rpc.go</code>。</li>
<li>map的输出文件存放在当前目录。</li>
<li><code>main/mrmaster.go</code>需要<code>mr/master.go</code>实现<code>Done()</code>方法，在MapReduce任务完成后返回TRUE，好让mrmaster.go终止。</li>
<li>当任务完成猴，worker进行需要终止。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fanyingjie11.github.io/2022/05/07/MEC%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F.png">
      <meta itemprop="name" content="Yingjie Fan">
      <meta itemprop="description" content="飞得比别人高">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="夏天不热">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/07/MEC%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">《More Effective C++》阅读（一）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-07 17:31:45" itemprop="dateCreated datePublished" datetime="2022-05-07T17:31:45+08:00">2022-05-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-12 17:39:12" itemprop="dateModified" datetime="2022-05-12T17:39:12+08:00">2022-05-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">程序设计</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="基础议题">基础议题</h1>
<p>涉及四个条款，主要涉及指针和引用的区别、C++转型操作符、数组和构造函数。</p>
<h2 id="仔细区别指针和引用">仔细区别指针和引用</h2>
<ol type="1">
<li>有空指针但没有空引用，如果需要一个变量可能指向也可能不指向一个对象，则需要用指针。</li>
<li>引用可能比指针效率更高，因为没有空引用，所以不需要检查是否为空。</li>
<li>指针可以被重新赋值，引用不行。</li>
</ol>
<p>一个特例是，重载操作符[]时，必须返回引用，因为返回的东西必须能被赋值。</p>
<p>总结：当需要指向某个东西，且不会改变其指向时，或者指针不能满足需求时，使用引用。其他情况使用指针。</p>
<h2 id="最好使用c转型操作符">最好使用C++转型操作符</h2>
<p>C语言的()转型有很多缺点，C++提供了更好的控制。</p>
<p>static_cast基本和C的转型相同（想起腾讯的面试题：static_cast和C语言类型转换的区别。。。）</p>
<p>const_cast只能用来去除变量的const属性上，其余用法皆是错的。</p>
<p>dynamic_cast用于继层体系中向下转型，转型失败返回空指针（转型对象是指针）或抛异常（转型对象是引用）。</p>
<p>reinterpret_cast最常用于转换函数指针的类型（建议少用，记得muduo里面用过）。</p>
<h2 id="绝不以多态方式处理数组">绝不以多态方式处理数组</h2>
<p>根本原因是，如果利用基类的指针或引用指向派生类的数组，而在代码中又含有（或者隐式含有）指针运算，则必然会出错，因为指针运算默认对象大小是基类的大小而非派生类的大小。</p>
<h2 id="非必要不提供默认构造函数">非必要不提供默认构造函数</h2>
<p>不提供默认构造函数有一下限制：</p>
<ol type="1">
<li>难以产生一个无默认构造函数的类的数组。</li>
<li>某些设计不佳的模板需要类系统默认构造函数。</li>
<li>继承体系中，如果没有默认构造函数，派生类必须提供自变量给父类的构造函数。</li>
</ol>
<p>关于第一点，文中给出几种解决办法。</p>
<p>一是定义非堆数组，在定义时给出必要的自变量。</p>
<p>二是使用指针，后面对每个指针在堆上构造对象，提供自变量，缺点很明显，指针太垃圾。</p>
<p>三是利用placement
new，先分配内存再构造对象，缺点是比较难，还需要在手动调用析构函数和operator
delete。</p>
<p>虽然有上述限制，但条款仍然成立，因为：若class内的某些对象可以是无意义的，那么成员函数就必须检查是否数据成员有意义，影响效率。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fanyingjie11.github.io/2022/05/05/Bigtable%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F.png">
      <meta itemprop="name" content="Yingjie Fan">
      <meta itemprop="description" content="飞得比别人高">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="夏天不热">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/05/Bigtable%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" class="post-title-link" itemprop="url">Bigtable论文阅读</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-05 16:31:17" itemprop="dateCreated datePublished" datetime="2022-05-05T16:31:17+08:00">2022-05-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-07 16:45:06" itemprop="dateModified" datetime="2022-05-07T16:45:06+08:00">2022-05-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/" itemprop="url" rel="index"><span itemprop="name">分布式存储</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" itemprop="url" rel="index"><span itemprop="name">论文阅读</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引言">引言</h1>
<p>Bigtable不完全支持关系模型，而是对用户提供简单的数据模型，动态控制数据格式和分布，可以让用户知道数据在底层存储的位置属性。Bigtable将col和row以及data看成字符串，用户通常将结构化或半结构化的数据序列化到字符串中。用户能够通过设计schema来控制数据的locality，同时能够控制哪些数据存放在内存。</p>
<h1 id="数据模式">数据模式</h1>
<p>一个运行Bigtable的服务器为多张表服务，表是一个分布式、稀疏、多维的有序map。组织数据的维度有三个：row、col、timestamp。</p>
<figure>
<img
src="/2022/05/05/Bigtable%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/image-20220505163137494.png"
alt="bigtable组织数据的三个维度" />
<figcaption aria-hidden="true">bigtable组织数据的三个维度</figcaption>
</figure>
<p>通过这三个维度唯一确定的数据称为一个cell。多行被group起来，成为负载均衡的单元，多列被group起来，成为访问控制和资源计数的单元。</p>
<p>一个典型表的例子如下：</p>
<figure>
<img
src="/2022/05/05/Bigtable%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/image-20220505163523817.png"
alt="一个table的示例" />
<figcaption aria-hidden="true">一个table的示例</figcaption>
</figure>
<p><strong>row：</strong>按照字母顺序排序，可以是任意字符串，通常大小为10-100byte，最大允许64KB，读写单行是可串行化的，即Bigtable支持单行事务，但不支持跨行事务。多行被group起来形成一个tablet，这是数据分布和负载均衡的单元。用户可以设计行键来得到较好的局部性。例如，上图中的示例，行键是URL的翻转，这样，所有CNN的网站数据就离得比较近。</p>
<p><strong>col：</strong>col被group成column
family，这是访问控制的单元。通常一个column
family内的所有列是同类数据（会被一起压缩）。Bigtable的设计思路是，一张表可以有很多列，但column
family很少。修改column family就需要修改表的schema，只有添加了一个column
family之后，column
family中的所有列才能添加数据，并且向这些col中添加数据不会影响schema。因为Bigtable不支持多行事务，所以删除一列可能不是原子的。访问控制和磁盘与内存的统计都是在column
family水平上。</p>
<p><strong>timestamps：</strong>时间戳就是64bit的整数，可以是系统设置也可由用户设置，例如上面的表例子中，每个contents列下面的cell都有多个版本的数据，由时间戳进行索引，其中最新的内容放在最前面。可以设置两种版本管理方式，一种是保留最新的n个版本数据，另外一种是保留某个时间段内的版本数据。</p>
<h1 id="api">API</h1>
<figure>
<img
src="/2022/05/05/Bigtable%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/image-20220507090300117.png"
alt="一个典型谷歌机器上的进程" />
<figcaption aria-hidden="true">一个典型谷歌机器上的进程</figcaption>
</figure>
<p>上图是谷歌服务器上面跑的典型进程，其中Bigtable可以用作mapreduce的输出和输出。</p>
<figure>
<img
src="/2022/05/05/Bigtable%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/image-20220507090440198.png"
alt="读写操作代码" />
<figcaption aria-hidden="true">读写操作代码</figcaption>
</figure>
<p>上图是Bigtable的API的简单操作，论文通过操作说明了用户可以做哪些操作。</p>
<h1 id="building-blocks">Building blocks</h1>
<p>Bigtable基于谷歌的一些基础设施，例如谷歌的集群管理系统（好像没有进一步介绍）用来进行作业调度、shared
machines 的资源管理、监控系统状态以及处理机器失效。</p>
<p>基于GFS存储日志和数据文件。</p>
<p>用SSTable来存储Bigtable的数据文件（参考leveldb）。SSTable提供了持久化、有序且不可更改的键值对map。键和值是任意字节的字符串。可以提供查找指定key的value，或在给定key的范围内进行迭代。SSTable内部包含一系列block（默认64KB，可配置），SSTable末尾有block
index，用来定位block，block
index被缓存到内存中，这样查找给定key只需要一次磁盘寻道，首先在内存中查找需要访问的block，然后访问磁盘读取对应block。SSTable能够被映射进内存中。</p>
<p>Bigtable依赖高可用和持久化的分布式锁服务Chubby。一个Chubby服务包含五个活跃副本，其中一个被选举为master，并响应请求。只要多数副本是活跃的并且能相互通信就可以了。Chubby使用Paxos算法实现副本一致性。</p>
<h1 id="实现">实现</h1>
<p>Bigtable的实现有三个主要组件，一个链接到每个客户端的库、一个master服务器、多个tablet服务器。tablet服务器能够动态加入或删除。</p>
<p>master负责将tablet分配给tablet服务器，检测tablet服务器的添加或过期，均衡tablet服务器的负载，GFS中垃圾回收。</p>
<p>每个tablet服务器管理多个tablet，处理它上面的tablet的读写请求，并在tablet较大时进行分割。</p>
<p>客户端不依赖master进行读写请求，因为客户端不通过master获取tablet的位置信息。客户端直接与tablet服务器进行通信。</p>
<p>论文中说，尽管模型支持任意大小的数据集，但建议客户单行数据不要超过几百GB（啊这，有点装逼的意思）</p>
<h2 id="tablet的位置">tablet的位置</h2>
<figure>
<img
src="/2022/05/05/Bigtable%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/image-20220507093902814.png"
alt="tablet的位置层级模式" />
<figcaption aria-hidden="true">tablet的位置层级模式</figcaption>
</figure>
<p>Chubby中包含了root tablet的位置信息，root tablet中包含了metadata
tablet的位置信息，metadata tablet包含用户tablet的位置信息。</p>
<p>Metadata tablet中每一行存储一个tablet所属的table
ID和tablet包含的最后一行的编码。tablet的位置信息存储在内存中，不需要访问GFS。</p>
<h2 id="tablet分配">tablet分配</h2>
<p>每个tablet最多的分配给一个tablet服务器，master跟踪活着的tablet服务器和当前的tablet到服务器的分配，以及哪些tablet未被分配。</p>
<p>Bigtable使用Chubby来跟踪tablet服务器，每个tablet服务器在一个指定的Chubby目录下创建名称唯一的文件，并获取其上的排他锁。master监控这个目录以发现tablet服务器。tablet服务器停止服务，如果它失去了排他锁，若该文件还存在，那么tablet服务器会重新请求一个排他锁，如果文件不存在，tablet服务器自杀。</p>
<p>master负责检测tablet服务器是否在提供服务，并尽快重新分配tablets。为了检测出不再提供服务的tablet服务器，master周期性地询问每个tablet服务器它的锁状态。如果tablet服务器报告锁不在它这，或者联系不上tablet服务器，则master尝试获取该tablet服务器的锁。如果master能够获取锁，那么说明Chubby是活着的，而tablet服务器要么死了，要么不能联系Chubby，所以master删除该tablet服务器对应的文件来指示该服务器不再提供服务。这样，master可以对该tablet服务器上的tablet进行重新分配。</p>
<p>在master的Chubby租约过期时，master自杀，保证就算master和Chubby之间的网络出现故障，系统也是健壮的。</p>
<p>当一个master被集群管理系统启动时，它需要发现当前的tablet分配信息。master在启动时需要执行的步骤是：</p>
<ol type="1">
<li>获取Chubby上的master lock，阻止并发master实例化。</li>
<li>查看Chubby上的servers目录，发现活着的服务器</li>
<li>与活着的tablet服务器通信，发现tablet分配信息，并通知tablet服务器新的master生成。</li>
<li>master查看Metadata
table，学习table集合。每碰见一个未分配的tablet，就添加到未分配集合中，使得该tablet能够有机会被分配。</li>
</ol>
<p>一个比较复杂的情况是，当metadata tablet没有被分配是，metadata
table不能被查询，所以，在开始第四步之前，如果root
tablet没有被发现，master就将root
tablet添加到未分配集合中。这样就能确保root tablet将被分配。因为root
tablet包含所有metadata tablet的信息，master将在查询root
tablet之后知道这些信息。</p>
<h2 id="tablet服务器">tablet服务器</h2>
<figure>
<img
src="/2022/05/05/Bigtable%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/image-20220507110728925.png"
alt="tablet的持久化状态" />
<figcaption aria-hidden="true">tablet的持久化状态</figcaption>
</figure>
<p>上图是tablet的持久化状态，更新被提交到commit log（redo
log），最近的提交被保存在内存中一个叫做memtable的有序缓冲中。旧的更新存放在SSTable中，是不可修改的。</p>
<p>为了恢复tablet，tablet服务器从Metadata
table中读取该tablet的元数据，包括组成该tablet的SSTable的列表、redo
point（指向commit log）。服务器通过重放redo point之后的commit
log来重构memtable。</p>
<p>当写操作到达，tablet服务器进行检查，确认发送方被授权进行修改。授权检查需要读取Chubby文件（通常在Chubby客户端中有缓存）。有效的修改被写入commit
log（采用了group
commit，提高小的写入操作的吞吐）。在写入被提交之后，写入的内容被插入memtable。</p>
<p>读操作也要检查授权等。SSTable和memtable提供一个合并的视图。由于SSTable和memtable是字母表排序的数据结构，因此查询高效。</p>
<h2 id="压缩">压缩</h2>
<p>这部分完全可以看看leveldb的设计思路，基本上是一致的。</p>
<p>随着写操作进行，memtable不断增大，达到一个门限以后，memtable被冻结并转换成SSTable，写入GFS。这个过程被称为<em>minor
compaction</em>。该过程主要目的有两个：一个是减少tablet服务器的内存使用，第二个是当数据丢失时，减少需要从commit
log读取的数据量。</p>
<p>每个minor compaction会创建一个SSTable，通过周期性地执行<em>merging
compaction</em>操作，将SSTable的数量限制在指定范围内。merging
compaction读取memtable和一些SSTable的数据，合并成一个SSTable，这样输入的memtable和SSTable就可被删除。</p>
<p>全部SSTable和memtable合并成一个SSTable的过程称为<em>major
compaction</em>，non-major
compactions可能还没有完全清除已经被删除的数据，而是打上标记，major
compaction之后将不存在任何已被删除的数据。major
compaction允许Bigtable回收被删除数据占用的资源。</p>
<p>Bigtable的读性能受益于GFS的局部性优化，GFS会把一份副本直接存在写者的本地磁盘。</p>
<h2 id="schema管理">schema管理</h2>
<p>Bigtable的schema存储在Chubby中，Chubby提供了写文件的原子性和小文件的一致性缓存。假如客户端想要删除某个column
family，首先master进行访问控制校验，验证删除操作有良好行为，然后通过重写Chubby中保存的schema文件，安装新的schema。当tablet服务器要确认某个column
family是否存在，只需要从Chubby读取对应的schema文件即可（通常缓存在服务器的Chubby客户端上）。由于Chubby的缓存是一致的，所以保证tablet服务器看得到所有修改。</p>
<h1 id="优化">优化</h1>
<p><strong>Locality Groups </strong>：用户可以指定每个column
family到一个Locality Group。一个tablet中的每个Locality
Group在压缩过程生成单独的SSTable。将通常不在一起访问的column
family分别放在不同的Locality Group可以有较好的读效率。针对每个Locality
Group有一个可调控的参数，例如一个Locality
Group可以被申明为存在内存中，Metadata
table就利用这个特性将tablet-location放到内存中。</p>
<p><strong>Compression</strong>：用户可以指定一个locality group
中的SSTable是否要压缩。SSTable中的每个block被分别压缩，这虽然损失了一定的磁盘空间，但这使得不用解压整个文件，一个SSTable的一小部分就能够被读取。论文着重强调了压缩速率和压缩空间。压缩比可以达到10-1。</p>
<p><strong>Caching for Read
Performance</strong>：tablet服务器有两种缓存，一种是Scan
Cache，是较高层次的缓存，缓存键值对，对于重复读写相同数据的应用来讲很有帮助。还有一种是Block
Cache，是较低层次的缓存，缓存的是通过GFS读取的SSTable的block，对于读取已经读到的数据附近的数据有帮助。</p>
<p><strong>Bloom
Filters</strong>：用来判断一个指定了row或column的数据是否在SSTable中，减少了磁盘访问次数。</p>
<p><strong>Commit-Log Implementation</strong>：commit
log不是每个tablet一份，而是一个tablet服务器一份，这样就避免了并发向GFS写日志，并且可以更好地利用group
commit。</p>
<p>但是这就引入了一个新问题，那就是当tablet服务器失效时，它所包含的tablet都要分配到其他许多服务器上，这些服务器都需要访问这个tablet服务器的commit
log，相当于读放大。为了解决该问题，采用了对commit log
entries进行排序的方法，按照&lt;table,row name,log sequence
number&gt;进行。这样，对某个特定的tablet，所有的记录都是连续的，因此可以被高效读取。为了并发排序，还将日志文件分割为64MB的片段，在不同的tablet服务器上排序不同的片段（这段没懂）。</p>
<p>为了保护写日志免受GFS延迟峰值的影响，采用两个线程写日志，一个时刻采用一个线程进行写入，如果写入很差，就换另外一个线程写。</p>
<p><strong>Speeding Up Tablet
Recovery</strong>：在unload一个tablet之前，tablet服务器首先做一次minor
compaction，在完成这次compaction之后，tablet服务器停止为该tablet提供服务，然后再做一次minor
compaction（这次很快），最后才会unload该tablet。这样做的好处是，消除了所有处于uncompacted状态的log，这样该tablet能够直接load到别的tablet服务器，而不需要恢复log
entry。</p>
<p><strong>Exploiting
Immutability</strong>：SSTable是不可修改的，这大大简化了系统很多方面的实现。例如：不需要在读取SSTable时提供同步访问，同时行级的并发控制很容易，因为只有memtable是可变的，为了减少拥塞，memtable采用了COW技术，允许读写并发。</p>
<p>后面两段没看懂hhh。。。</p>
<h1 id="性能分析">性能分析</h1>
<p>略过不谈</p>
<h1 id="经验">经验</h1>
<ol type="1">
<li>大规模分布式系统是很脆弱的</li>
<li>延迟添加新的特性，直到确定新特性将会被用到</li>
<li>系统级监测很有用</li>
<li>简单设计的价值</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fanyingjie11.github.io/2022/04/26/mapreduce%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F.png">
      <meta itemprop="name" content="Yingjie Fan">
      <meta itemprop="description" content="飞得比别人高">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="夏天不热">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/26/mapreduce%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" class="post-title-link" itemprop="url">mapreduce论文阅读</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-04-26 10:45:35 / 修改时间：17:08:08" itemprop="dateCreated datePublished" datetime="2022-04-26T10:45:35+08:00">2022-04-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/" itemprop="url" rel="index"><span itemprop="name">分布式存储</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" itemprop="url" rel="index"><span itemprop="name">论文阅读</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="问答">问答</h1>
<h2 id="mapreduce是干啥的">mapreduce是干啥的？</h2>
<p>答：mapreduce是一个编程模型，用来处理和生成大规模数据集。用户通过指定map和reduce函数以及输入数据等，将计算任务表达为mapreduce的任务。即使是没有分布式系统编程经验的程序员，也可以通过mapreduce来利用大规模集群，因为mapreduce帮助管理好一切，包括输入数据分区、调度多台机器上的程序执行、处理机器故障和管理机器间的通信等。</p>
<h2 id="为什么需要mapreduce">为什么需要mapreduce？</h2>
<p>谷歌内部有上百个需要处理大型数据集的专门实现，这些实现的缺点是掩盖了本来很简单的计算任务，因为需要处理数据分布、负载均衡、故障容错等问题。而mapreduce能够将简单的计算任务从复杂的分布式实现中剥离开来。</p>
<h1 id="编程模型">编程模型</h1>
<p>mapreduce的输入输出都是键值对，map和reduce函数由用户指定。map函数接收输入的键值对，并生成中间键值对，所有相同键的值会被组合起来，并被传递给reduce函数。reduce函数接收一个中间键以及该键的所有值。</p>
<h2 id="例子">例子</h2>
<p>wordcount：统计所有文件中每个单词出现的次数。</p>
<p>map和reduce函数的伪代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">map(String key, String value):</span><br><span class="line">// key: document name</span><br><span class="line">// value: document contents</span><br><span class="line">for each word w in value:</span><br><span class="line">EmitIntermediate(w, &quot;1&quot;);</span><br><span class="line"></span><br><span class="line">reduce(String key, Iterator values):</span><br><span class="line">// key: a word</span><br><span class="line">// values: a list of counts</span><br><span class="line">int result = 0;</span><br><span class="line">for each v in values:</span><br><span class="line">result += ParseInt(v);</span><br><span class="line">Emit(AsString(result));</span><br></pre></td></tr></table></figure>
<p>map函数接收一个文件名为key，文件内容为值的键值对，对于文件内容中每一个单词，都emit一个中间键值对，key是word，值是“1”。</p>
<p>reduce函数接收一个key为word，值为list的键值对，并合并所有的值，最终得到一个结果键值对，键还是word，值是合并的统计值。</p>
<h2 id="类型">类型</h2>
<figure>
<img
src="/2022/04/26/mapreduce%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/image-20220426170804898.png"
alt="image-20220426170804898" />
<figcaption aria-hidden="true">image-20220426170804898</figcaption>
</figure>
<p>论文中给出了通常map和reduce的输入输出类型。其中，中间键值对和输出键值对有相同的key。</p>
<p>在C++实现中，map和reduce的输入输出都是string类型，让用户来处理类型转换问题。</p>
<h1 id="实现">实现</h1>
<p>论文中提到针对不同的环境可以有不同的实现，他们针对的环境是谷歌内部的环境。</p>
<h2 id="执行流程">执行流程</h2>
<p>整个mapreduce的执行流程图如下。</p>
<ol type="1">
<li>首先将输入文件分割成M份，每份通常16MB至64MB（用户可指定）。将程序拷到集群的机器上。<code>这里可以看到，文件分割的大小和GFS底层chunk的大小相近</code></li>
<li>有一份特殊的程序拷贝，就是master。master需要将总共M个map
task和R个reduce task分配到空闲的机器上。</li>
<li>接收了map
task的worker，读取相应的文件块，解析键值对并传递给map函数，同时将生成的中间键值对缓存在内存中。</li>
<li>缓存的键值对被分区函数分为R份，并周期性地写入本地磁盘。这些写入位置被报告给master，master负责将这些信息通告reduce
worker。</li>
<li>reduce worker利用RPC读取map
worker生成的文件，对收集到的所有中间键值对进行排序，相同键的值被组合起来。</li>
<li>将排完序后的键值对传给reduce函数，将结果append到该reduce分区对应的输出文件中。</li>
<li>流程结束，返回用户代码。</li>
</ol>
<figure>
<img
src="/2022/04/26/mapreduce%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/image-20220426105253732.png"
alt="mapreduce工作流程图" />
<figcaption aria-hidden="true">mapreduce工作流程图</figcaption>
</figure>
<h2 id="master数据结构">master数据结构</h2>
<p>master为每个map和reduce函数存储了状态信息（idle, in-progress, or
completed)，并为每个非空闲任务记录worker的ID。</p>
<p>master还负责保存map生成文件的位置和大小，并传递给reduce worker。</p>
<h2 id="容错">容错</h2>
<p>主要的容错机制就是重试，master会周期性地ping每一个worker，如果超时就将该worker标记为故障，将该worker上所有map
task状态置为idle，允许这些task重新分配。对于失效worker上的reduce
task，处于in
progress状态的task会被标记为idle，以允许重新分配，而completed状态的reduce
task不需要重新执行，这时候由GFS来保证reduce
task的输出文件可用。（因为map
task生成的中间文件是写入本地磁盘而非GFS，所以失效worker上的completed的task也要重新执行）</p>
<h3 id="master失效">master失效</h3>
<p>虽然master有checkpoint机制，但论文中假定master不太可能失效，如果master失效就停止mapreduce任务，让用户检查并重试。</p>
<h3 id="出现失效时的语义">出现失效时的语义</h3>
<p>对于具有函数性的map和reduce函数（就是说相同的输入能得到相同的输出），mapreduce提供比较好的语义，即mapreduce的执行结果和没有失效发生时的执行结果是相同的。这个保证依赖于map和reduce执行结果的原子提交，文中只是简单提了一嘴。</p>
<p>对于非函数性的map或reduce
task，mapreduce不保证执行结果和不发生失效时执行结果完全一致。</p>
<h2 id="局部性">局部性</h2>
<p>master收集GFS中文件的位置信息，并将map
task放在尽量靠近输入数据的机器上，所以map
task中大多数输入数据的读取是locally的。</p>
<h2 id="任务粒度">任务粒度</h2>
<p>一共M个map task以及R个reduce
task，我们希望任务尽量细分，让M+R远大于机器总数，这样负载均衡效果好，并且如果某台机器失效，它上面的任务可以均衡分配至别的机器上。但是M+R也不能过大，一个实际的约束是空间消耗，例如master需要为每个task维护一些状态信息。</p>
<p>进一步，R通常由用户指定，通常选择一个合适的M，使得每个task的输入大小为16到64MB，这样可以利用局部性优化。R通常选取为机器数量多小的倍数。</p>
<h2 id="备份任务">备份任务</h2>
<p>主要是为了解决straggler
的问题，即某些task执行很慢，拖慢了整个mapreduce的进度。解决办法是在mapreduce任务接近完成时，将那些还为完成的task备份执行，即两个task同时执行相同的任务，这样只要一个完成了，那么这个task就完成了。</p>
<p>这样做增加了少量计算资源的开销，但任务执行时间显著减少。</p>
<h1 id="refinements">Refinements</h1>
<h2 id="分区函数partitioning-function">分区函数（Partitioning
Function）</h2>
<p>每个map
worker在生成中间文件时，需要分区函数来对数据进行划分，划分的数量由用户指定的reduce
task/输出文件个数所决定（每个reduce
task会生成一个输出文件）。默认的分区函数是哈希<code>hash(key) mod R</code>，这样负载均衡会很好。然而有时需要特殊的分区函数，例如，想要将所有相同host的url划分到相同分区，则可以选择分区函数<code>hash(Hostname(urlkey)) mod R</code>。</p>
<h2 id="顺序保证">顺序保证</h2>
<p>reduce
task在处理一个给定分区的数据时，会按照key升序进行处理（在读取完整的分区的中间数据后，reduce
worker会对数据进行排序），这样保证了输出文件是有序的。这样做的好处是，支持输出文件针对key的高效随机查询，或者方便了那些需要输出文件有序的用户。</p>
<h2 id="combiner-function">Combiner Function</h2>
<p>我们可以想象，map函数所emit的中间键值对中有很多重复的KEY，我们可以提前combine这些KEY，减少资源浪费。例如，wordCount中，由于齐夫定律，会出现很多重复的<code>&lt;the, 1&gt;</code>，可以提前进行合并。合并函数通常和reduce函数相同，不过输出文件位置不一样。</p>
<h1 id="性能测试">性能测试</h1>
<p>1800台机器的集群，每台机器4G内存、两个2GHz处理器、两个160G磁盘。两层交换机，根交换机聚合带宽100-200Gbps。这个环境和GFS中的类似。</p>
<h2 id="grep">Grep</h2>
<p>Grep任务需要从10^10个大小为100byte的记录中，筛选出符合特定模式的记录（92337条）。输入文件划分为64MB(M=
15000)，map的输出放在一个文件里（R=1）。</p>
<figure>
<img
src="/2022/04/26/mapreduce%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/image-20220426163554895.png"
alt="Grep执行过程中数据读取速率" />
<figcaption aria-hidden="true">Grep执行过程中数据读取速率</figcaption>
</figure>
<p>上图是输入数据的读取速率。峰值速率为30GB/s，这个时候集群中大多数节点都启动了，开始读取数据。后面map任务逐渐完成，读取速率开始下降。</p>
<h2 id="sort">Sort</h2>
<p>总数据量还是和Grep一样。map函数从每条记录中提取key，并emit提取的key和原始文本行。reduce函数为内置的Identity函数，原样输出得到的数据。</p>
<p>输入文件划分为64MB(M=
15000)，输出划分为4000个文件（R=4000）。分区函数使用key的初始几个字节，将数据划分为4000份。</p>
<p>这里的分区函数使用了先验的key分布知识，通常的排序需要预先对key进行采样，根据采样得到的分布进行数据分区。</p>
<figure>
<img
src="/2022/04/26/mapreduce%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/image-20220426164829004.png"
alt="Sort执行中的数据传输速率" />
<figcaption aria-hidden="true">Sort执行中的数据传输速率</figcaption>
</figure>
<p>上图为执行Sort任务时的数据传输速率，从最上方的图可以看到，map执行时的峰值速率为13GB，比前面Grep的要低，这是因为Sort中的map函数需要写入本地磁盘的中间数据量很大，这占用了大约一半的IO带宽。而Grep的中间数据大小可忽略。</p>
<p>中间的图是shuffling过程，即reduce worker从map
worker读数据的过程。可以看到，第一个map任务完成，reduce任务就立即开始读数据。有两个驼峰，第一个峰表示的是第一次批处理1700个reduce任务，大约300s处理完成，开始第二批任务，大约600s整个shuffling过程结束。可以看出shuffle的速率低于map阶段的输入速率，因为map阶段的读取基本都是local的，而shuffle有很多网络传输。</p>
<p>下面的图是reduce
worker写数据的速率。可以看到，从第一个shuffle完成到第一个reduce
worker开始写入，中间有一段时间间隔，因为中间数据需要进行排序。写入速率低于shuffle的速率，因为写入是往GFS里面写，要写双副本。</p>
<p>论文后面还分析了备份任务和故障恢复对性能的影响，这里就不列举了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fanyingjie11.github.io/2022/04/18/%E5%A6%82%E4%BD%95%E8%AE%A9markdown%E4%B8%AD%E5%85%AC%E5%BC%8F%E5%9C%A8hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%98%BE%E7%A4%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F.png">
      <meta itemprop="name" content="Yingjie Fan">
      <meta itemprop="description" content="飞得比别人高">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="夏天不热">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/18/%E5%A6%82%E4%BD%95%E8%AE%A9markdown%E4%B8%AD%E5%85%AC%E5%BC%8F%E5%9C%A8hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%98%BE%E7%A4%BA/" class="post-title-link" itemprop="url">如何让markdown中公式在hexo博客中显示</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-04-18 22:58:02 / 修改时间：23:15:33" itemprop="dateCreated datePublished" datetime="2022-04-18T22:58:02+08:00">2022-04-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/hexo/" itemprop="url" rel="index"><span itemprop="name">hexo</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>主要参考了下面这篇帖子：</p>
<p><a
target="_blank" rel="noopener" href="https://dog.wtf/tech/making-hexo-next-theme-latex-math-equation-supported/">让
Hexo Next (v8.0.0) 支持 LaTeX 数学公式</a></p>
<p>步骤如下：</p>
<ol type="1">
<li>安装<a
target="_blank" rel="noopener" href="https://pandoc.org/installing.html">pandoc</a>，并配置config.yml文件。</li>
</ol>
<p>由于我是win10系统，直接下载了zip文件，并解压到D盘（解压位置可任意）。然后在博客的根目录下的_config.yml文件最后面加上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pandoc:</span><br><span class="line">  pandoc_path: D:/pandoc-2.18-windows-x86_64/pandoc-2.18/pandoc.exe</span><br></pre></td></tr></table></figure>
<p>上面的绝对路径就是解压出来的pandoc.exe文件的路径，一定需要加到配置文件里，不然会找不到而报错。</p>
<ol start="2" type="1">
<li>更换默认渲染引擎</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm un hexo-renderer-marked</span><br><span class="line">npm i hexo-renderer-pandoc</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>修改next主题配置文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">math:</span><br><span class="line">  # Default (true) will load mathjax / katex script on demand.</span><br><span class="line">  # That is it only render those page which has `mathjax: true` in Front-matter.</span><br><span class="line">  # If you set it to false, it will load mathjax / katex srcipt EVERY PAGE.</span><br><span class="line">  per_page: true</span><br><span class="line"></span><br><span class="line">  # hexo-renderer-pandoc (or hexo-renderer-kramed) required for full MathJax support.</span><br><span class="line">  mathjax:</span><br><span class="line">    enable: true</span><br><span class="line">    # See: https://mhchem.github.io/MathJax-mhchem/</span><br><span class="line">    mhchem: false</span><br><span class="line"></span><br><span class="line">  # hexo-renderer-markdown-it-plus (or hexo-renderer-markdown-it with markdown-it-katex plugin) required for full Katex support.</span><br><span class="line">  katex:</span><br><span class="line">    enable: false</span><br><span class="line">    # See: https://github.com/KaTeX/KaTeX/tree/master/contrib/copy-tex</span><br><span class="line">    copy_tex: false</span><br></pre></td></tr></table></figure>
<p>需要注意的点：</p>
<ul>
<li>mathjax和katex只能有一个enable，我选择mathjax，相比katex，mathjax更重量级，但对LaTeX支持更好。</li>
<li>per_page即可以设置为true，也可以设置为false。设置为true的含义是，需要人为在博文最前面的格式控制（title那一栏）中添加上mathjax:
true，对指定的博文进行渲染。false表示对所有博文进行渲染，所以无需添加额外的东西了。这里我为了效率考虑，选择true，只不过如果后面写的博文需要渲染，则必须手动添加mathjax:
true。</li>
</ul>
<p>到这里就可以开心地让博文显示LaTeX公式了。</p>
<p>最后提一个编写公式需要注意的地方，行内公式的内容和$符号之间不要有空格，不然可能出现typora能显示，hexo博文显示错误的问题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fanyingjie11.github.io/2022/04/18/%E7%89%9B%E9%A1%BF%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F.png">
      <meta itemprop="name" content="Yingjie Fan">
      <meta itemprop="description" content="飞得比别人高">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="夏天不热">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/18/%E7%89%9B%E9%A1%BF%E6%B3%95/" class="post-title-link" itemprop="url">牛顿迭代法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-04-18 20:34:19 / 修改时间：22:33:46" itemprop="dateCreated datePublished" datetime="2022-04-18T20:34:19+08:00">2022-04-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">数学</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="牛顿迭代法">牛顿迭代法</h1>
<p>在阅读SICP时，在1.1.7节提到了牛顿迭代法，之前的研究生课程《工程优化》中学过，然而很快就忘了，这里旧事重提一下。</p>
<p>牛顿迭代法属于一种一维搜索算法，可以用来求函数<span
class="math inline">\(f(x)\)</span>的零点的近似值，原理如下：</p>
<p>根据<span class="math inline">\(f(x)\)</span>在<span
class="math inline">\({x_n}\)</span>处的一阶泰勒展开式： <span
class="math display">\[
\begin{equation}
f(x) = f\left( {x_n} \right) + f&#39;({x_n})(x - {x_n})
\end{equation}
\]</span></p>
<p>将上式看做<span
class="math inline">\(f(x)\)</span>的近似，那么令<span
class="math inline">\(f(x)=0\)</span>，我们有 $$ 
\begin{equation}
x = {x_n} - \frac{{f({x_n})}}{{f'({x_n})}}
\end{equation}
$$ 
这就是下一轮迭代的新位置，即<span class="math inline">\({x_{n +
1}}\)</span>的值。利用上面的公式，一直迭代到满足条件为止。</p>
<p>迭代的终止条件是很重要的，考虑到计算机的位数限制和舍入误差，一般根据两次相继迭代的结果，计算相对误差，让该误差小于特定值。</p>
<p><img
src="/2022/04/18/%E7%89%9B%E9%A1%BF%E6%B3%95/image-20220418210146454.png" /></p>
<p><img
src="/2022/04/18/%E7%89%9B%E9%A1%BF%E6%B3%95/image-20220418210212254.png" /></p>
<p>牛顿迭代法的几何含义是，用线性逼近曲线。具体可以参考下面这篇文章。</p>
<p><a
target="_blank" rel="noopener" href="https://www.zhihu.com/question/20690553">如何通俗易懂地讲解牛顿迭代法求开方（数值分析）？</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fanyingjie11.github.io/2022/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E8%A7%A3%E9%87%8A%20%E7%AC%AC%E4%B8%80%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F.png">
      <meta itemprop="name" content="Yingjie Fan">
      <meta itemprop="description" content="飞得比别人高">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="夏天不热">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E8%A7%A3%E9%87%8A%20%E7%AC%AC%E4%B8%80%E7%AB%A0/" class="post-title-link" itemprop="url">《计算机程序的构造和解释》书籍阅读</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-04-18 10:10:37 / 修改时间：23:12:42" itemprop="dateCreated datePublished" datetime="2022-04-18T10:10:37+08:00">2022-04-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">程序设计</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近开始读《计算机程序的构造和解释》，英文名是《structure and
interpretation of computer
programs》，简称SICP。囫囵吞枣地读，花了一个周末将前面一二章的内容大致扫了一遍，练习题基本没做。现在想写一个笔记之类的东西，边读边记录自己的收获。</p>
<p>这本书在我看来是比较基础的，但是又是高屋建瓴并且具有一定难度的。说它基础是因为，本书不涉及现代的高级语言，例如C++、JAVA之类的程序，相反，采用了一个早期语言Lisp。但是这本书又全然不是关于Lisp语言特性的描述，而是讲一个更高层次的东西，关于语言的设计和表达能力的东西。我相信这些东西既是基础的，同时又很抽象，将本书的哲学和方法论应用到别的编程语言是有很大价值的。</p>
<h1 id="过程抽象">过程抽象</h1>
<p>本章主要围绕过程这一名词展开，讲了程序设计的基础知识，Lisp的基本语法，过程的表达能力，如何对过程进行抽象，高阶过程的意义等等。采用Lisp这门语言的理由如下：</p>
<blockquote>
<p>正如我们将要看到的，Lisp可以将过程作为数据进行处理的灵活性，使它成为探索这些技术的最方便的现存语言之一</p>
</blockquote>
<h2 id="程序设计的基本元素">程序设计的基本元素</h2>
<p>语言不仅是命令计算机执行的命令，也是一个容纳我们组织计算过程思想的容器。为了将简单的认知组合起来，形成更复杂的认知，每种语言都提供了三种机制：</p>
<ul>
<li>基本表达式</li>
<li>组合的方法</li>
<li>抽象的方法</li>
</ul>
<p>基本表达式就是语言最基础的表示简单认知的东西，组合的方法能够将简单的认知组合成较复杂的认知，而抽象的方法能够将组合在一起的东西作为一个整体去认知。</p>
<h3 id="表达式">表达式</h3>
<p>简单讲了一下和Lisp解释器的交互，前缀表示和美观打印。</p>
<h3 id="命名和环境">命名和环境</h3>
<p>就讲了一个<code>define</code>，可以将名称和一个复杂组合式相关联，这是最简单的抽象方法。</p>
<p>而为了维护这样一种对象和名称的关联，解释器需要维护某种存储能力，这种存储被称为<em>环境</em>。</p>
<h3 id="组合式求值">组合式求值</h3>
<p>组合式的求值过程是递归的：</p>
<ol type="1">
<li>求该组合的各个子表达式。</li>
<li>将最左边的子表达式的过程应用于相应的实际参数（也就是其他子表达式的值）。</li>
</ol>
<p>可以把这种递归计算看成一种树形结构，求值的过程就是从叶子到根的<em>树形累积</em>。</p>
<p>这种递归会一直持续，直到遇见一个基本表达式，处理这些基本表达式的规则就是：</p>
<ol type="1">
<li>数的值就是它们所表示的数值。</li>
<li>其他名字的值就是环境中能完成相应操作的机器指令序列。</li>
</ol>
<p>这里又提到了环境，环境扮演的角色是，用于确定表达式中各个符号的意义，为求值过程提供一种上下文。</p>
<p>除了上述一般性的求值规则外，还有一些特殊形式，例如define就是一例。</p>
<h3 id="复合过程">复合过程</h3>
<p>这里有一个名词上的区分，将加减乘除这些解释器自带的过程称为<em>基本过程</em>，将程序中定义的过程称为<em>复合过程</em>。过程其实就是函数，也是用define去定义。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(define (&lt;name&gt; &lt;paramenters&gt;) &lt;body&gt;)</span><br></pre></td></tr></table></figure>
<p>可以用过程去构造另一个过程。</p>
<h3 id="过程的应用代换模型">过程的应用代换模型</h3>
<p>主要讲了两种代换方式，应用序和正则序。正则序是先代换，直到全部是基本符号之后，再计算。应用序相反，是先计算参数的值，再进行代换。</p>
<h3 id="条件表达式和谓词">条件表达式和谓词</h3>
<p>术语<em>谓词</em>指那些返回真或假的过程。条件表达式cond：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(cond (&lt;p1&gt; &lt;e1&gt;)</span><br><span class="line">	  (&lt;p2&gt; &lt;e2&gt;)</span><br><span class="line">	  ......</span><br><span class="line">	  (&lt;pn&gt; &lt;en&gt;)</span><br></pre></td></tr></table></figure>
<p>其结果是从上往下，遇到的第一个为真的p所对应的e值。</p>
<p>最后一个(<pn> <en>)可以用（else e）。</p>
<p>if表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(if &lt;predicate&gt;&lt;consequent&gt;&lt;alternative&gt;)</span><br></pre></td></tr></table></figure>
<p>结果二选一。</p>
<p>除了基本谓词&gt;&lt;=，还有复合的表达式，and、or、not等。</p>
<h3 id="实例采用牛顿法求平方根">实例：采用牛顿法求平方根</h3>
<p>数学函数，像<span class="math inline">\(y = {x^2}\)</span>
是说明性的，为了求它的根，计算机程序需要行动性的描述。计算机求平方根最常用的方法是牛顿迭代。</p>
<p>如果对<span
class="math inline">\(x\)</span>的平方根有了一个猜测值<span
class="math inline">\(y\)</span>，那么就能够通过<span
class="math inline">\(y\)</span>和<span
class="math inline">\(x/y\)</span>的平均值进行下一次逼近。牛顿迭代法准备单独细讲。</p>
<h3 id="过程作为黑箱抽象">过程作为黑箱抽象</h3>
<p>过程可以分解为多个子过程。一个求平方的过程square，对于使用者而言是一个黑箱，或者说抽象过程。使用者只考虑这个过程返回的是一个数的平方，而不需要弄清楚它是如何实现的。</p>
<p>为了让过程用户不用关心过程的实现细节，一个重要的点就是过程的意义不依赖于形参的名字。过程的形式参数必须是局部的（只在过程内部起作用）。我们成过程的形参为<em>约束变量</em>，约束形参的表达式集合就是形参的作用域。</p>
<p>为了让过程局部化，可以允许一个过程带有一些内部定义（define里面套define）。这种嵌套的定义称为块结构。</p>
<h2 id="过程及其产生的计算">过程及其产生的计算</h2>
<h3 id="线性递归和迭代">线性递归和迭代</h3>
<p>文中基于<span
class="math inline">\(n!\)</span>的计算方式，给了两种算法，一个是线性递归，一个迭代计算。</p>
<p>注意不要搞混了<em>递归计算过程</em>和<em>递归过程</em>的概念，如果一个过程内部调用了自身，那它就是一个递归过程，然而计算过程却不一定是递归的。递归过程的计算过程可能是迭代的。</p>
<p>注意<em>迭代的计算过程</em>和<em>递归的计算过程</em>的区别。迭代的计算过程只需要有限的几个变量来保持系统当前的计算状态，而递归的计算过程中，解释器需要维护一个将要执行的操作的轨迹。</p>
<p>文中提到，有些语言对于任何递归过程的解释，都需要消耗与过程调用数目成正比的存储量，为了在这些语言中实现迭代，就必须采用特殊的循环结构，例如for、while。而Scheme的实现则没有这一缺陷，总能在常量空间中执行迭代计算过程，即使它是一个递归过程，具有这一特性的实现称为<strong>尾递归</strong>的。</p>
<h3 id="树形递归">树形递归</h3>
<p>文中给出了计算斐波拉契数的简单树形递归版本和一个迭代版本。而后给出一个实例，换零钱的方式统计，并给出了一个树形递归的版本，要读者给出一个迭代的版本。其实这个问题</p>
<h3 id="增长的阶">增长的阶</h3>
<p>也就是评估算法计算复杂度那一套。</p>
<h3 id="求幂">求幂</h3>
<p>计算<span
class="math inline">\({b^n}\)</span>可以线性的递归也可以采用线性的迭代计算，而更快速的计算方式是对数级的。</p>
<p>练习1.19给出一个对数级的计算斐波拉契数的算法（貌似leetcode上面做过）。</p>
<h3 id="最大公约数">最大公约数</h3>
<p>欧几里得算法，算法的阶是对数级。</p>
<h3 id="素数检测">素数检测</h3>
<p>检查整数<span
class="math inline">\(n\)</span>是否是素数有两种算法，第一种具有<span
class="math inline">\(O(\sqrt n )\)</span>的阶，第二种具有<span
class="math inline">\(O(\log n)\)</span>的阶。</p>
<p>第一种算法是，从<span
class="math inline">\(2\)</span>开始一步步直到不超过<span
class="math inline">\(\sqrt n\)</span>的整数，一个个尝试能够整除<span
class="math inline">\(n\)</span>。</p>
<p>第二种算法是，利用费马小定理。</p>
<p><strong>费马小定理</strong>：如果<span
class="math inline">\(n\)</span>是一个素数，<span
class="math inline">\(a\)</span>是小于<span
class="math inline">\(n\)</span>的任意正整数，那么<span
class="math inline">\(a\)</span>的<span
class="math inline">\(n\)</span>次方与<span
class="math inline">\(a\)</span>模<span
class="math inline">\(n\)</span>同余。</p>
<p>这是一种概率算法，如果不能通过费马检查，那么可以确定<span
class="math inline">\(n\)</span>一定不是素数，如果能通过费马检查，则我们更加相信<span
class="math inline">\(n\)</span>是素数。</p>
<h2 id="用高阶函数做抽象">用高阶函数做抽象</h2>
<h3 id="过程作为参数">过程作为参数</h3>
<p>操作过程的过程称为高阶过程，高阶过程是强有力的抽象机制，极大增强了语言的表达能力。</p>
<p>从数学上的求和公式出发，解释了抽象模式的存在，和求和符号一样，可以建立一个公共模式，用来求某一类问题。</p>
<p>同时还给出了一个用公共模式sum进行积分的近视计算的例子。</p>
<h3 id="用lambda构造过程">用lambda构造过程</h3>
<p>不用显示定义一个过程。通过引入lambda特殊形式来完成这一过程，而无需定义辅助过程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lambda (&lt;parameters&gt;) &lt;body&gt;)</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fanyingjie11.github.io/2022/04/14/typora%E5%92%8Chexo%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%E7%9A%84%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F.png">
      <meta itemprop="name" content="Yingjie Fan">
      <meta itemprop="description" content="飞得比别人高">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="夏天不热">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/14/typora%E5%92%8Chexo%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%E7%9A%84%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">typora和hexo图片显示的问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-14 11:11:41" itemprop="dateCreated datePublished" datetime="2022-04-14T11:11:41+08:00">2022-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-29 08:35:44" itemprop="dateModified" datetime="2022-04-29T08:35:44+08:00">2022-04-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/hexo/" itemprop="url" rel="index"><span itemprop="name">hexo</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="问题发现">问题发现</h1>
<p>最近自己捣鼓了一下博客，按照网上教程一步步来，把博客弄好了，迫不及待地发布了一篇文章，结果发现图片无法显示。上网一查发现是由于hexo和markdown的图片引用格式不一致。于是又Google了半天，终于把问题给比较好地解决了。</p>
<h1 id="解决方案">解决方案</h1>
<p>首先，对typora的设置进行调整，让图片自动保存到相同位置的同名文件夹下。</p>
<p><img
src="/2022/04/14/typora%E5%92%8Chexo%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%E7%9A%84%E9%97%AE%E9%A2%98/image-20220414111729211.png" /></p>
<p>这样，如果我如果在D:\Blog\source\posts目录下建了一个A.md文件，则对应就会在相同目录下出现一个A文件夹，里面保存了A.md中的所有图片。</p>
<p>接下来，需要利用一个插件（hexo-asset-link），首先安装插件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -s hexo-asset-link</span><br></pre></td></tr></table></figure>
<p>设置config.yml文件中的post_asset_folder为true</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure>
<p>然后就是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>完事了，可以发现图片既能在typora中显示，也能在博客中正常显示。</p>
<p>需要注意的问题是，在引用图片时，需要满足格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![XX](A/XXX.png)</span><br></pre></td></tr></table></figure>
<p>也就是说，需要圆括号里面是相对路径，方括号里的内容只是对该图片进行说明。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yingjie Fan"
      src="/images/%E5%A4%B4%E5%83%8F.png">
  <p class="site-author-name" itemprop="name">Yingjie Fan</p>
  <div class="site-description" itemprop="description">飞得比别人高</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fanyingjie11" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fanyingjie11" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/yjfan_1@foxmail.com" title="E-Mail → yjfan_1@foxmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://fanyingjie11.github.io/2022/04/13/GFS%E8%AF%BB%E5%90%8E%E7%AC%94%E8%AE%B0/" title="https:&#x2F;&#x2F;fanyingjie11.github.io&#x2F;2022&#x2F;04&#x2F;13&#x2F;GFS%E8%AF%BB%E5%90%8E%E7%AC%94%E8%AE%B0&#x2F;">GFS笔记</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; Wed Apr 13 2022 08:00:00 GMT+0800 (中国标准时间) – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yingjie Fan</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


</body>

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
</html>
