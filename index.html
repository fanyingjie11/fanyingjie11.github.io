<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fanyingjie11.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="飞得比别人高">
<meta property="og:type" content="website">
<meta property="og:title" content="夏天不热">
<meta property="og:url" content="https://fanyingjie11.github.io/index.html">
<meta property="og:site_name" content="夏天不热">
<meta property="og:description" content="飞得比别人高">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Yingjie Fan">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://fanyingjie11.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>夏天不热</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">夏天不热</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fanyingjie11.github.io/2022/04/18/%E5%A6%82%E4%BD%95%E8%AE%A9markdown%E4%B8%AD%E5%85%AC%E5%BC%8F%E5%9C%A8hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%98%BE%E7%A4%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F.png">
      <meta itemprop="name" content="Yingjie Fan">
      <meta itemprop="description" content="飞得比别人高">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="夏天不热">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/18/%E5%A6%82%E4%BD%95%E8%AE%A9markdown%E4%B8%AD%E5%85%AC%E5%BC%8F%E5%9C%A8hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%98%BE%E7%A4%BA/" class="post-title-link" itemprop="url">如何让markdown中公式在hexo博客中显示</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-04-18 22:58:02 / 修改时间：23:15:33" itemprop="dateCreated datePublished" datetime="2022-04-18T22:58:02+08:00">2022-04-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/hexo/" itemprop="url" rel="index"><span itemprop="name">hexo</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>主要参考了下面这篇帖子：</p>
<p><a
target="_blank" rel="noopener" href="https://dog.wtf/tech/making-hexo-next-theme-latex-math-equation-supported/">让
Hexo Next (v8.0.0) 支持 LaTeX 数学公式</a></p>
<p>步骤如下：</p>
<ol type="1">
<li>安装<a
target="_blank" rel="noopener" href="https://pandoc.org/installing.html">pandoc</a>，并配置config.yml文件。</li>
</ol>
<p>由于我是win10系统，直接下载了zip文件，并解压到D盘（解压位置可任意）。然后在博客的根目录下的_config.yml文件最后面加上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pandoc:</span><br><span class="line">  pandoc_path: D:/pandoc-2.18-windows-x86_64/pandoc-2.18/pandoc.exe</span><br></pre></td></tr></table></figure>
<p>上面的绝对路径就是解压出来的pandoc.exe文件的路径，一定需要加到配置文件里，不然会找不到而报错。</p>
<ol start="2" type="1">
<li>更换默认渲染引擎</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm un hexo-renderer-marked</span><br><span class="line">npm i hexo-renderer-pandoc</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>修改next主题配置文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">math:</span><br><span class="line">  # Default (true) will load mathjax / katex script on demand.</span><br><span class="line">  # That is it only render those page which has `mathjax: true` in Front-matter.</span><br><span class="line">  # If you set it to false, it will load mathjax / katex srcipt EVERY PAGE.</span><br><span class="line">  per_page: true</span><br><span class="line"></span><br><span class="line">  # hexo-renderer-pandoc (or hexo-renderer-kramed) required for full MathJax support.</span><br><span class="line">  mathjax:</span><br><span class="line">    enable: true</span><br><span class="line">    # See: https://mhchem.github.io/MathJax-mhchem/</span><br><span class="line">    mhchem: false</span><br><span class="line"></span><br><span class="line">  # hexo-renderer-markdown-it-plus (or hexo-renderer-markdown-it with markdown-it-katex plugin) required for full Katex support.</span><br><span class="line">  katex:</span><br><span class="line">    enable: false</span><br><span class="line">    # See: https://github.com/KaTeX/KaTeX/tree/master/contrib/copy-tex</span><br><span class="line">    copy_tex: false</span><br></pre></td></tr></table></figure>
<p>需要注意的点：</p>
<ul>
<li>mathjax和katex只能有一个enable，我选择mathjax，相比katex，mathjax更重量级，但对LaTeX支持更好。</li>
<li>per_page即可以设置为true，也可以设置为false。设置为true的含义是，需要人为在博文最前面的格式控制（title那一栏）中添加上mathjax:
true，对指定的博文进行渲染。false表示对所有博文进行渲染，所以无需添加额外的东西了。这里我为了效率考虑，选择true，只不过如果后面写的博文需要渲染，则必须手动添加mathjax:
true。</li>
</ul>
<p>到这里就可以开心地让博文显示LaTeX公式了。</p>
<p>最后提一个编写公式需要注意的地方，行内公式的内容和$符号之间不要有空格，不然可能出现typora能显示，hexo博文显示错误的问题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fanyingjie11.github.io/2022/04/18/%E7%89%9B%E9%A1%BF%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F.png">
      <meta itemprop="name" content="Yingjie Fan">
      <meta itemprop="description" content="飞得比别人高">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="夏天不热">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/18/%E7%89%9B%E9%A1%BF%E6%B3%95/" class="post-title-link" itemprop="url">牛顿迭代法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-04-18 20:34:19 / 修改时间：22:33:46" itemprop="dateCreated datePublished" datetime="2022-04-18T20:34:19+08:00">2022-04-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">数学</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="牛顿迭代法">牛顿迭代法</h1>
<p>在阅读SICP时，在1.1.7节提到了牛顿迭代法，之前的研究生课程《工程优化》中学过，然而很快就忘了，这里旧事重提一下。</p>
<p>牛顿迭代法属于一种一维搜索算法，可以用来求函数<span
class="math inline">\(f(x)\)</span>的零点的近似值，原理如下：</p>
<p>根据<span class="math inline">\(f(x)\)</span>在<span
class="math inline">\({x_n}\)</span>处的一阶泰勒展开式： <span
class="math display">\[
\begin{equation}
f(x) = f\left( {x_n} \right) + f&#39;({x_n})(x - {x_n})
\end{equation}
\]</span></p>
<p>将上式看做<span
class="math inline">\(f(x)\)</span>的近似，那么令<span
class="math inline">\(f(x)=0\)</span>，我们有 $$ 
\begin{equation}
x = {x_n} - \frac{{f({x_n})}}{{f'({x_n})}}
\end{equation}
$$ 
这就是下一轮迭代的新位置，即<span class="math inline">\({x_{n +
1}}\)</span>的值。利用上面的公式，一直迭代到满足条件为止。</p>
<p>迭代的终止条件是很重要的，考虑到计算机的位数限制和舍入误差，一般根据两次相继迭代的结果，计算相对误差，让该误差小于特定值。</p>
<p><img
src="/2022/04/18/%E7%89%9B%E9%A1%BF%E6%B3%95/image-20220418210146454.png" /></p>
<p><img
src="/2022/04/18/%E7%89%9B%E9%A1%BF%E6%B3%95/image-20220418210212254.png" /></p>
<p>牛顿迭代法的几何含义是，用线性逼近曲线。具体可以参考下面这篇文章。</p>
<p><a
target="_blank" rel="noopener" href="https://www.zhihu.com/question/20690553">如何通俗易懂地讲解牛顿迭代法求开方（数值分析）？</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fanyingjie11.github.io/2022/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E8%A7%A3%E9%87%8A%20%E7%AC%AC%E4%B8%80%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F.png">
      <meta itemprop="name" content="Yingjie Fan">
      <meta itemprop="description" content="飞得比别人高">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="夏天不热">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E8%A7%A3%E9%87%8A%20%E7%AC%AC%E4%B8%80%E7%AB%A0/" class="post-title-link" itemprop="url">《计算机程序的构造和解释》书籍阅读</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-04-18 10:10:37 / 修改时间：23:12:42" itemprop="dateCreated datePublished" datetime="2022-04-18T10:10:37+08:00">2022-04-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">程序设计</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近开始读《计算机程序的构造和解释》，英文名是《structure and
interpretation of computer
programs》，简称SICP。囫囵吞枣地读，花了一个周末将前面一二章的内容大致扫了一遍，练习题基本没做。现在想写一个笔记之类的东西，边读边记录自己的收获。</p>
<p>这本书在我看来是比较基础的，但是又是高屋建瓴并且具有一定难度的。说它基础是因为，本书不涉及现代的高级语言，例如C++、JAVA之类的程序，相反，采用了一个早期语言Lisp。但是这本书又全然不是关于Lisp语言特性的描述，而是讲一个更高层次的东西，关于语言的设计和表达能力的东西。我相信这些东西既是基础的，同时又很抽象，将本书的哲学和方法论应用到别的编程语言是有很大价值的。</p>
<h1 id="过程抽象">过程抽象</h1>
<p>本章主要围绕过程这一名词展开，讲了程序设计的基础知识，Lisp的基本语法，过程的表达能力，如何对过程进行抽象，高阶过程的意义等等。采用Lisp这门语言的理由如下：</p>
<blockquote>
<p>正如我们将要看到的，Lisp可以将过程作为数据进行处理的灵活性，使它成为探索这些技术的最方便的现存语言之一</p>
</blockquote>
<h2 id="程序设计的基本元素">程序设计的基本元素</h2>
<p>语言不仅是命令计算机执行的命令，也是一个容纳我们组织计算过程思想的容器。为了将简单的认知组合起来，形成更复杂的认知，每种语言都提供了三种机制：</p>
<ul>
<li>基本表达式</li>
<li>组合的方法</li>
<li>抽象的方法</li>
</ul>
<p>基本表达式就是语言最基础的表示简单认知的东西，组合的方法能够将简单的认知组合成较复杂的认知，而抽象的方法能够将组合在一起的东西作为一个整体去认知。</p>
<h3 id="表达式">表达式</h3>
<p>简单讲了一下和Lisp解释器的交互，前缀表示和美观打印。</p>
<h3 id="命名和环境">命名和环境</h3>
<p>就讲了一个<code>define</code>，可以将名称和一个复杂组合式相关联，这是最简单的抽象方法。</p>
<p>而为了维护这样一种对象和名称的关联，解释器需要维护某种存储能力，这种存储被称为<em>环境</em>。</p>
<h3 id="组合式求值">组合式求值</h3>
<p>组合式的求值过程是递归的：</p>
<ol type="1">
<li>求该组合的各个子表达式。</li>
<li>将最左边的子表达式的过程应用于相应的实际参数（也就是其他子表达式的值）。</li>
</ol>
<p>可以把这种递归计算看成一种树形结构，求值的过程就是从叶子到根的<em>树形累积</em>。</p>
<p>这种递归会一直持续，直到遇见一个基本表达式，处理这些基本表达式的规则就是：</p>
<ol type="1">
<li>数的值就是它们所表示的数值。</li>
<li>其他名字的值就是环境中能完成相应操作的机器指令序列。</li>
</ol>
<p>这里又提到了环境，环境扮演的角色是，用于确定表达式中各个符号的意义，为求值过程提供一种上下文。</p>
<p>除了上述一般性的求值规则外，还有一些特殊形式，例如define就是一例。</p>
<h3 id="复合过程">复合过程</h3>
<p>这里有一个名词上的区分，将加减乘除这些解释器自带的过程称为<em>基本过程</em>，将程序中定义的过程称为<em>复合过程</em>。过程其实就是函数，也是用define去定义。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(define (&lt;name&gt; &lt;paramenters&gt;) &lt;body&gt;)</span><br></pre></td></tr></table></figure>
<p>可以用过程去构造另一个过程。</p>
<h3 id="过程的应用代换模型">过程的应用代换模型</h3>
<p>主要讲了两种代换方式，应用序和正则序。正则序是先代换，直到全部是基本符号之后，再计算。应用序相反，是先计算参数的值，再进行代换。</p>
<h3 id="条件表达式和谓词">条件表达式和谓词</h3>
<p>术语<em>谓词</em>指那些返回真或假的过程。条件表达式cond：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(cond (&lt;p1&gt; &lt;e1&gt;)</span><br><span class="line">	  (&lt;p2&gt; &lt;e2&gt;)</span><br><span class="line">	  ......</span><br><span class="line">	  (&lt;pn&gt; &lt;en&gt;)</span><br></pre></td></tr></table></figure>
<p>其结果是从上往下，遇到的第一个为真的p所对应的e值。</p>
<p>最后一个(<pn> <en>)可以用（else e）。</p>
<p>if表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(if &lt;predicate&gt;&lt;consequent&gt;&lt;alternative&gt;)</span><br></pre></td></tr></table></figure>
<p>结果二选一。</p>
<p>除了基本谓词&gt;&lt;=，还有复合的表达式，and、or、not等。</p>
<h3 id="实例采用牛顿法求平方根">实例：采用牛顿法求平方根</h3>
<p>数学函数，像<span class="math inline">\(y = {x^2}\)</span>
是说明性的，为了求它的根，计算机程序需要行动性的描述。计算机求平方根最常用的方法是牛顿迭代。</p>
<p>如果对<span
class="math inline">\(x\)</span>的平方根有了一个猜测值<span
class="math inline">\(y\)</span>，那么就能够通过<span
class="math inline">\(y\)</span>和<span
class="math inline">\(x/y\)</span>的平均值进行下一次逼近。牛顿迭代法准备单独细讲。</p>
<h3 id="过程作为黑箱抽象">过程作为黑箱抽象</h3>
<p>过程可以分解为多个子过程。一个求平方的过程square，对于使用者而言是一个黑箱，或者说抽象过程。使用者只考虑这个过程返回的是一个数的平方，而不需要弄清楚它是如何实现的。</p>
<p>为了让过程用户不用关心过程的实现细节，一个重要的点就是过程的意义不依赖于形参的名字。过程的形式参数必须是局部的（只在过程内部起作用）。我们成过程的形参为<em>约束变量</em>，约束形参的表达式集合就是形参的作用域。</p>
<p>为了让过程局部化，可以允许一个过程带有一些内部定义（define里面套define）。这种嵌套的定义称为块结构。</p>
<h2 id="过程及其产生的计算">过程及其产生的计算</h2>
<h3 id="线性递归和迭代">线性递归和迭代</h3>
<p>文中基于<span
class="math inline">\(n!\)</span>的计算方式，给了两种算法，一个是线性递归，一个迭代计算。</p>
<p>注意不要搞混了<em>递归计算过程</em>和<em>递归过程</em>的概念，如果一个过程内部调用了自身，那它就是一个递归过程，然而计算过程却不一定是递归的。递归过程的计算过程可能是迭代的。</p>
<p>注意<em>迭代的计算过程</em>和<em>递归的计算过程</em>的区别。迭代的计算过程只需要有限的几个变量来保持系统当前的计算状态，而递归的计算过程中，解释器需要维护一个将要执行的操作的轨迹。</p>
<p>文中提到，有些语言对于任何递归过程的解释，都需要消耗与过程调用数目成正比的存储量，为了在这些语言中实现迭代，就必须采用特殊的循环结构，例如for、while。而Scheme的实现则没有这一缺陷，总能在常量空间中执行迭代计算过程，即使它是一个递归过程，具有这一特性的实现称为<strong>尾递归</strong>的。</p>
<h3 id="树形递归">树形递归</h3>
<p>文中给出了计算斐波拉契数的简单树形递归版本和一个迭代版本。而后给出一个实例，换零钱的方式统计，并给出了一个树形递归的版本，要读者给出一个迭代的版本。其实这个问题</p>
<h3 id="增长的阶">增长的阶</h3>
<p>也就是评估算法计算复杂度那一套。</p>
<h3 id="求幂">求幂</h3>
<p>计算<span
class="math inline">\({b^n}\)</span>可以线性的递归也可以采用线性的迭代计算，而更快速的计算方式是对数级的。</p>
<p>练习1.19给出一个对数级的计算斐波拉契数的算法（貌似leetcode上面做过）。</p>
<h3 id="最大公约数">最大公约数</h3>
<p>欧几里得算法，算法的阶是对数级。</p>
<h3 id="素数检测">素数检测</h3>
<p>检查整数<span
class="math inline">\(n\)</span>是否是素数有两种算法，第一种具有<span
class="math inline">\(O(\sqrt n )\)</span>的阶，第二种具有<span
class="math inline">\(O(\log n)\)</span>的阶。</p>
<p>第一种算法是，从<span
class="math inline">\(2\)</span>开始一步步直到不超过<span
class="math inline">\(\sqrt n\)</span>的整数，一个个尝试能够整除<span
class="math inline">\(n\)</span>。</p>
<p>第二种算法是，利用费马小定理。</p>
<p><strong>费马小定理</strong>：如果<span
class="math inline">\(n\)</span>是一个素数，<span
class="math inline">\(a\)</span>是小于<span
class="math inline">\(n\)</span>的任意正整数，那么<span
class="math inline">\(a\)</span>的<span
class="math inline">\(n\)</span>次方与<span
class="math inline">\(a\)</span>模<span
class="math inline">\(n\)</span>同余。</p>
<p>这是一种概率算法，如果不能通过费马检查，那么可以确定<span
class="math inline">\(n\)</span>一定不是素数，如果能通过费马检查，则我们更加相信<span
class="math inline">\(n\)</span>是素数。</p>
<h2 id="用高阶函数做抽象">用高阶函数做抽象</h2>
<h3 id="过程作为参数">过程作为参数</h3>
<p>操作过程的过程称为高阶过程，高阶过程是强有力的抽象机制，极大增强了语言的表达能力。</p>
<p>从数学上的求和公式出发，解释了抽象模式的存在，和求和符号一样，可以建立一个公共模式，用来求某一类问题。</p>
<p>同时还给出了一个用公共模式sum进行积分的近视计算的例子。</p>
<h3 id="用lambda构造过程">用lambda构造过程</h3>
<p>不用显示定义一个过程。通过引入lambda特殊形式来完成这一过程，而无需定义辅助过程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lambda (&lt;parameters&gt;) &lt;body&gt;)</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fanyingjie11.github.io/2022/04/14/typora%E5%92%8Chexo%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%E7%9A%84%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F.png">
      <meta itemprop="name" content="Yingjie Fan">
      <meta itemprop="description" content="飞得比别人高">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="夏天不热">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/14/typora%E5%92%8Chexo%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%E7%9A%84%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">typora和hexo图片显示的问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-14 11:11:41" itemprop="dateCreated datePublished" datetime="2022-04-14T11:11:41+08:00">2022-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-18 23:04:48" itemprop="dateModified" datetime="2022-04-18T23:04:48+08:00">2022-04-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/hexo/" itemprop="url" rel="index"><span itemprop="name">hexo</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="问题发现">问题发现</h1>
<p>最近自己捣鼓了一下博客，按照网上教程一步步来，把博客弄好了，迫不及待地发布了一篇文章，结果发现图片无法显示。上网一查发现是由于hexo和markdown的图片引用格式不一致。于是又Google了半天，终于把问题给比较好地解决了。</p>
<h1 id="解决方案">解决方案</h1>
<p>首先，对typora的设置进行调整，让图片自动保存到相同位置的同名文件夹下。</p>
<p><img
src="/2022/04/14/typora%E5%92%8Chexo%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%E7%9A%84%E9%97%AE%E9%A2%98/image-20220414111729211.png" /></p>
<p>这样，如果我如果在D:\Blog\source\posts目录下建了一个A.md文件，则对应就会在相同目录下出现一个A文件夹，里面保存了A.md中的所有图片。</p>
<p>接下来，需要利用一个插件（hexo-asset-link），首先安装插件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -s hexo-asset-link</span><br></pre></td></tr></table></figure>
<p>设置config.yml文件中的post_asset_folder为true</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure>
<p>然后就是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>完事了，可以发现图片既能在typora中显示，也能在博客中正常显示。</p>
<p>需要注意的问题是，在引用图片时，需要满足格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![XXX](A/XXX.png)</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fanyingjie11.github.io/2022/04/13/GFS%E8%AF%BB%E5%90%8E%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F.png">
      <meta itemprop="name" content="Yingjie Fan">
      <meta itemprop="description" content="飞得比别人高">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="夏天不热">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/13/GFS%E8%AF%BB%E5%90%8E%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">《The Google File System》论文阅读</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-13 21:45:22" itemprop="dateCreated datePublished" datetime="2022-04-13T21:45:22+08:00">2022-04-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-18 23:08:07" itemprop="dateModified" datetime="2022-04-18T23:08:07+08:00">2022-04-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/" itemprop="url" rel="index"><span itemprop="name">分布式存储</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" itemprop="url" rel="index"><span itemprop="name">论文阅读</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言">前言</h1>
<p>GFS是Google内部广泛使用的大规模分布式文件系统，适用于大的分布式数据密集型应用。GFS的设计和之前的分布式文件系统的主要区别在于，设计目标有很多不同：</p>
<ol type="1">
<li>设备失效是常态而不是例外。</li>
<li>从传统标准看，文件通常较大（几GB）。因此IO操作和块大小的设计需要重新考虑。</li>
<li>大多数文件仅append新数据，不会覆盖写旧的数据。一个文件内的随机写基本不存在。一次写入，后面只读，并且是顺序读。所以append成了性能优化的关键，同时，在客户端缓存数据失去了吸引力。</li>
<li>联合设计文件系统API和应用程序对整个系统有好处。</li>
</ol>
<p>GFS在谷歌内部最大的集群有超过一千台机器、上千个磁盘和几百TB的数据，同时被上百个客户端并发访问。</p>
<h1 id="设计总览">设计总览</h1>
<h2 id="一些设计上的前提">一些设计上的前提</h2>
<p>这些设计的前提条件是通过分析谷歌内部的应用工作负载和技术环境得到的：</p>
<ol type="1">
<li>设备失效是常态。</li>
<li>文件通常比较大，100MB、几个GB。也要支持小文件，但不针对性优化。</li>
<li>工作负载有两种读取：一是大的流式读取，通常几百KB、1MB。而是小的随机读取，通常几KB（一般会对小的随机读做排序和批处理）。</li>
<li>写操作通常是大的顺序append。操作大小和读相近。小的随机写也支持，但不优化。</li>
<li>必须对多个客户端并发的append操作提供良好的语义。文件通常用作生产者消费者队列或者多路归并。上百个生产者，同时对一个文件做append。要以最小的同步开销实现原子append。文件后面会被一个消费者读取（GFS能够支持高效的N:1队列）。</li>
<li>高的持续带宽比低时延更重要。应用程序通常注重高速批量处理数据，而不是单个读写请求的响应时间。</li>
</ol>
<h2 id="接口">接口</h2>
<p>GFS没有实现POSIX
接口，文件被目录组织成层级结构，并支持create、delete、open等操作。</p>
<p>重点是，GFS支持低开销的快照snapshot和原子append（record
append）。</p>
<h2 id="总体架构">总体架构</h2>
<figure>
<img
src="/2022/04/13/GFS%E8%AF%BB%E5%90%8E%E7%AC%94%E8%AE%B0/GFS架构图.png"
alt="GFS整体架构图" />
<figcaption aria-hidden="true">GFS整体架构图</figcaption>
</figure>
<p>上图是GFS的整体架构，有几个重要角色，chunkserver、client、master，通常都是运行在Linux上的用户进程。</p>
<p>文件被划分为固定大小的chunk（这个大小很有讲究，后面会说）。每个chunk被一个不可更改且全局唯一的64bit
<em>chunk
handle</em>标识，并在这个chunk被创建的时候赋值。chunkserver将chunk存储为本地的linux文件。读写chunk中的数据需要chunk
handle以及字节范围。为了可靠性，一个chunk被存储多份，在不同的机器上（高可用一章会讲）。</p>
<p>master负者维护所有元数据。包括namespace、访问控制信息、从文件到chunk的映射、chunk的当前位置。同时master也控制系统级的行为，例如chunk租约管理、垃圾回收、chunk迁移。master与chunkserver进行周期性的心跳通信，来下发指令和搜集状态。</p>
<p>client链接到应用程序，提供文件系统API。client与master交互，进行元数据操作，但数据通信直接与chunkserver进行。</p>
<p>client不缓存文件数据（但缓存元数据）。因为client缓存文件没有多大的好处，应用程序的工作数据集非常大，缓存了没用。这样做也消除了缓存一致性的问题。chunkserver不需要缓存文件数据，因为本身Linux的buffer
cache将经常使用的数据放在了内存。</p>
<h2 id="single-master">single master</h2>
<p>使用单个master大大简化了系统设计。然而必须最小化master参与数据读写的程度，使它不成为一个瓶颈。client从来不通过master读写文件数据，而是询问master需要和哪个chunkserver联系。并且client会缓存这个信息一段时间，并在接下来的操作中直接和chunkserver交互。</p>
<p>下面描述一个简单的读数据流程：首先，client将应用程序指定的文件名和字节偏移量翻译成文件中的chunk
index。然后，client发送给master一个请求，包含文件名和chunk
index。master响应以chunk
handle和副本的位置。client缓存这些信息，用文件名和chunk
index当作KEY。然后client发送一个请求给其中一个副本，通常是最近的一个。请求指定了chunk
handle和一个字节范围。读写相同的chunk不需要额外的client-master交互，一直到缓存的信息失效或者文件被重新open。事实上，client和master通信的时候可以多要几个还没有被请求的接下来的chunk的信息，或者master主动多给几个，这样可以节省接下来的client-master交互，并且基本没有额外的开销。</p>
<h2 id="chunk-size">chunk size</h2>
<p>chunk大小是一个设计的关键参数，GFS默认是64MB，远大于典型的文件系统块大小。这样做有几个好处：</p>
<ol type="1">
<li>减少了client-master交互</li>
<li>client更可能在一个给定的chunk上执行一系列操作，这样可以通过和一个固定的chunkServer建立持久TCP连接来降低通信开销。</li>
<li>减少了master的存储开销。</li>
</ol>
<p>缺点是：小文件可能导致热点问题。如果一个小文件只包含例如一个chunk，而同时有很多client想要访问该文件。文中举了一个例子，一个可执行文件写到了GFS的一个chunk里，同时启动上百个机器，每个机器都请求这个文件，导致chunkserver过载了。解决办法是：用高的复制因子存储该文件，并利用批处理程序错开应用启动时间。一个潜在的长期解决方案时，让client在这种情况下可以从别的client读数据。</p>
<h2 id="metadata">metadata</h2>
<p>master存储三种元数据，文件和chunk的namespace、从文件到chunk的映射、chunk副本的位置。三种数据都存放在内存里，同时前面两类数据持久化到硬盘（通过<em>operator
log</em>），并且为了高可用，还要复制到别的机器上。使用log是为了保证master故障的时候防止数据不一致。</p>
<p>master不存chunk的位置。</p>
<h3 id="内存数据结构">内存数据结构</h3>
<p>元数据全部放在内存可以加速master的操作。master需要周期性地扫描它的整个状态，用来进行垃圾回收、加副本、chunk迁移、磁盘空间利用。</p>
<p>不用担心内存不够用。</p>
<h3 id="chunk位置">chunk位置</h3>
<p>master并不持久化chunk的位置，从哲学上讲，只有chunkserver知道它所有的chunk，master持久化了也没用。这样做消除了master和chunkserver同步的问题。</p>
<h3 id="operation-log">operation log</h3>
<p>operation
log是master唯一持久化的东西，不仅是为了持久化，还为并发操作提供时间线。</p>
<p>必须可靠存储operation
log，在持久化之前，修改对用户不可见。只有在本地和远端机器上都做了持久化，才对client进行响应。同时为了加速，master将多个log合并刷盘，这样可以减少对系统吞吐的影响。</p>
<p>master可以通过重放operation
log恢复文件系统的状态。为了最小化启动时间，需要让log尽可能少，这就需要checkpoint。同时，为了加速，本文的checkpoint还有这样一个特性，就是可以直接加载到内存，用来进行namespace的查询，而不需要解析，这又加速了恢复过程，提高了可用性。</p>
<p>为了让checkpoint不影响正常的操作，master转到一个新的log文件上，同时创建单独的线程执行checkpoint，将转换log之前的所有修改都包含进去。</p>
<h3 id="一致性模型">一致性模型</h3>
<h4 id="gfs的保证">GFS的保证</h4>
<p>这一部分感觉是最难懂的，需要结合后面三四章的内容一起看才能完全明白。这里就按照原文简单提一下。</p>
<p>文件的namespace的修改是原子的，这是通过读写锁保证的，后面会介绍。</p>
<p>对于文件本身的数据，按照我的理解，GFS提供的保证其实是比较弱的保证。对于串行没有其他client干扰的write和record
append，GFS保证一致性（这里的一致性的含义是，所有副本保存的数据是相同的），同时还保证defined语义。defined语义按照我的理解是不发生脏写，也就是多个并发执行的写操作不会互相覆盖，client可以在中间读取到某一次写操作的完整更新内容。由于串行执行，没有并发操作，当然满足defined语义了。</p>
<p>如果有并发执行的写操作，对于write而言，不满足defined但满足一致性。而对于record
append而言，不管有没有并发写操作，都是defined的，并且有穿插不一致性（但是基本没有影响），这个和record
append的实现有关，后面会讲。最后，失败的修改肯定是会导致不一致的了。</p>
<figure>
<img
src="/2022/04/13/GFS%E8%AF%BB%E5%90%8E%E7%AC%94%E8%AE%B0/一致性.png"
alt="读写一致性" />
<figcaption aria-hidden="true">读写一致性</figcaption>
</figure>
<p>对于前面提到串行的写操作，GFS通过（a）对所有副本执行相同顺序的修改操作
（b）使用chunk的版本号检测过时的副本（由于chunkserver下线导致修改丢失）
来实现。</p>
<p>过时的副本从不会被包含进一个修改中，也不会在client向master请求的时候，由master响应包含（具体机制后面讲）。后面自动被垃圾回收处理掉。但是由于client会缓存chunk的位置信息，所以有可能读到过时的副本数据。但是这个时间窗口被缓存过期时间和下一次open限制住了。另外由于大多数写操作都是append的，所以这种情况下client读到的只是提前结束的数据而不是过时的数据。当client联系master时，会立即得到新数据的位置。</p>
<h4 id="对应用程序的影响">对应用程序的影响</h4>
<p>GFS的应用程序能够容忍宽松的一致性模型。</p>
<p>实际应用程序基本全是append而非overwriting。典型的场景是，一个写者生成数据从头到尾。写者写完之后，给文件一个永久性的名称，或者周期性地checkpoint成功写入了多少。读者仅处理最后一次checkpoint之前的文件（处于defined状态）。</p>
<p>另一个典型场景是，多个写者同时append一个文件。根据record
append的语义，读者需要处理padding和重复数据：每个record都包含额外的信息例如校验和，所以读者能够区分和忽略掉额外的padding以及record的片段。如果读者不能忍受重复的record，可以过滤掉它们，通过唯一性ID。</p>
<h1 id="系统交互">系统交互</h1>
<p>在最小化master参与操作的前提下进行的设计。</p>
<h2 id="租约和修改顺序">租约和修改顺序</h2>
<p>租约的设计主要是为了最小化master的开销。master给某个chunk一个租约，这个chunk称为主副本（primary）。当每个修改（mutation）操作执行时，主副本选择对这个chunk执行的所有操作的顺序，所有副本都按相同顺序执行修改操作。因此，全局的修改顺序被master的租约顺序和主副本的执行顺序确定。</p>
<p>租约最开始有60s的超时，只要这个chunk被修改，主副本能够无限次地请求延长租约。这些请求和响应的包含在心跳中。</p>
<p>master即使失去了和主副本的通信，也能够在一个租约到期后，安全地将租约赋给别的副本。</p>
<figure>
<img
src="/2022/04/13/GFS%E8%AF%BB%E5%90%8E%E7%AC%94%E8%AE%B0/写控制流和数据流.png"
alt="写操作的控制流和数据流" />
<figcaption aria-hidden="true">写操作的控制流和数据流</figcaption>
</figure>
<p>下面解释上图中写操作流程。</p>
<ol type="1">
<li>client向master询问哪个chunkserver拥有当前chunk的租约，以及其余从副本的位置。</li>
<li>master响应主副本的标识和从副本的位置。client缓存这些信息，直到主副本不可达或响应以租约过期。</li>
<li>client发送数据给所有副本。这一步的优化后面有详细解释。</li>
<li>一旦所有副本确认收到数据，client向主副本发起写请求。主副本将收到的所有修改（可能来自不同的client）编号，并应用到本地状态。</li>
<li>主副本将写请求发送给从副本，每个从副本应用与主副本相同顺序的修改。</li>
<li>从副本告知主副本已完成修改。</li>
<li>主副本响应client。如果发生错误，例如主副本或主副本和从副本的子集出错，client将认为修改失败，并进行第三步到第七步的重试。</li>
</ol>
<p>如果写操作的数据超出一个chunk的大小，则GFS的client的代码将其分为多个写操作进行，但是这些写操作可能和别的client的写操作有交叉，因此可能被覆盖掉。因此，共享的文件区域可能最终包含不同client的片段，尽管所有副本的数据是相同的（一致的）。</p>
<h2 id="数据流">数据流</h2>
<p>通过解耦数据流和控制流，有效地使用网络。</p>
<ol type="1">
<li><p>为了充分利用每台机器的网络带宽，采用链式而非其他方式（例如树型）传输。因此，每台机器的全部出站带宽都用于尽可能快地传输数据，而不是在多个接收者之间分配。</p></li>
<li><p>为了避免网络瓶颈和高延迟，每台机器向前传送数据给距离最近的未收到数据的机器。例如，假设有四台机器s1到s4，client先发送数据给离他最近的机器s1，然后s1发送数据给离他最近的机器s2。。。</p></li>
<li><p>通过pipeline的方式传送数据，最小化延时。文中给了具体例子。</p></li>
</ol>
<h2 id="record-append">record append</h2>
<p>record
append类似于Linux中的O_APPEND。论文里面没有给出具体的实现方式，但是解释的确很详细。</p>
<p>步骤如下：从图2的第四步开始，client发送请求给主副本，主副本查看是否在append之后会超出一个chunk的最大大小，如果超出，就将当前chunk进行pad到最大大小，然后通知从副本一样这么做，最后告诉client对下一个chunk进行重试（append的数据量也是受限的）。如果没有超过大小限制，则主副本将数据append到本地，并告诉从副本写相同的数据到相同的偏移量处，最后响应client。</p>
<p>如果一个record
append失败了，client会进行重试，因此相同chunk的多个副本可能包含不一致的数据，例如相同record的重复数据。GFS不保证所有副本的数据完全相同，只保证数据至少被原子地成功写入一次。但这对读取没太大影响。</p>
<h2 id="快照">快照</h2>
<p>为了不影响后续的写操作，采用了写时复制技术。感觉也没什么好讲的。</p>
<h1 id="master相关">master相关</h1>
<h2 id="namespace管理和锁">namespace管理和锁</h2>
<p>读写锁，论文讲的也很简单。只需提一点，为了防止死锁，有一个全局的加锁顺序，首先按照namespace树的层级结构加锁，其次按照字典顺序加锁。</p>
<h2 id="副本放置">副本放置</h2>
<p>目标是提升可用性可靠性以及网络带宽的利用率。由于整个架构是跨机架的，机架内部机器的聚合带宽要比跨机架高。一般会放一个副本到别的机架的机器上。这样提供了跨机架的读的聚合带宽，但同时增加了写的跨机架的开销，这是一个tradeoff。</p>
<h2
id="创建re-replicationrebalancing">创建、re-replication、rebalancing</h2>
<p>这三个操作基本目标都类似，需要提高磁盘利用率，平衡负载，保证可靠性和可用性，并且还需要限制带宽的使用，避免影响应用程序。具体影响因素直接看论文。</p>
<h2 id="垃圾回收">垃圾回收</h2>
<p>GFS采用惰性垃圾回收机制。这比eager deletion的优势在于：</p>
<ol type="1">
<li><p>提供了一个统一和独立的方式，来清除不知道是否有用的chunk。简单并且可靠。</p></li>
<li><blockquote>
<p>其次，它将存储回收合并到 master
的常规后台活动中，例如定期扫描命名空间和与 chunkserver 的握手。
因此，它是分批完成的，成本是摊销的。</p>
</blockquote></li>
<li><p>防止意外的，不可逆的删除。</p></li>
</ol>
<p>惰性删除的缺点是：掩盖了某些应用优化存储开销的努力。解决办法是，如果已经删除的文件被再次明确删除，就回收存储空间，同时用户也可以指定不同而回收策略，针对namespace的不同部分。</p>
<h2 id="过时副本检测">过时副本检测</h2>
<p>GFS利用版本号（chunk version number ）区分过时的副本。</p>
<p>master和所有的副本都将版本号持久化，在每次master赋予一个新的租约的时候，就增加版本号。如果某个副本因为在此时变得不可用，则它的版本号不会增加。master将在chunkserver重启时检测到这个chunkserver有过时的副本（因为chunkserver在重启的时候会向master报告它的chunk集合以及这些chunk相关的版本号）。</p>
<p>对于过时的副本，master使用垃圾回收机制，在此之前它不会告诉client过时副本的存在。另外，在master与client和chunkserver通信过程中会带着chunk的版本号，这样client和chunkserver可以进行验证。</p>
<h1 id="容错和检测">容错和检测</h1>
<p>论文中提到，设计系统的最大挑战是面对故障。</p>
<h2 id="ha">HA</h2>
<p>使用两个策略达到高可用：快速恢复和副本机制</p>
<h3 id="快速恢复">快速恢复</h3>
<p>master和chunkserver都设计成可以在秒级恢复，事实上并不区分正常的终止和异常的终止，可以直接kill来结束进程。</p>
<h3 id="chunk复制">chunk复制</h3>
<p>没什么可说的，文中提到他们在想办法引入纠删码。</p>
<h3 id="master复制">master复制</h3>
<p>为了高可用，master的状态也要复制，它的operation
log和checkpoint被复制到多台机器。只有当所有master的副本都将log刷盘，才会认为一个修改提交了。</p>
<p>论文中提到“shadow”master，我认为这就是复制了master状态的机器，“shadow”master可以提高可用性，就算master故障了，“shadow”master也可以提供只读服务，所以增强了读可用。但是毕竟“shadow”master不是真正的master，会有一定得延迟（文中提到只有元数据读取会有短的延时）。</p>
<p>“shadow”master要读取operation
log并应用相同的修改到本地。它也在开始时和chunkserver通信获取chunk的位置信息，后面需要依赖于master更新这些信息。</p>
<h2 id="数据完整性">数据完整性</h2>
<p>直接比较不同副本的数据来验证数据完整性是不现实的，所以每个chunkserver使用校验和独自验证数据完整性。</p>
<p>每个chunk分为64kB的block，每个block都有一个32bit的校验和。和元数据一样，校验和保存在内存中，并被持久化到磁盘。</p>
<p>为了防止错误数据的传播，在chunkserver响应client或者别的chunkserver的请求时，会提前使用校验和进行检查。当发现错误时，chunkserver向请求者报告错误，并通知master，这样请求者可以去读取别的副本，master会克隆该chunk，在克隆后master会通知chunkserver删除错误数据。</p>
<p>校验和对读性能的影响很小，同时文中提到对于append操作，着重优化了校验和的计算。</p>
<p>在空闲的时候，chunkserver会用校验和检查那些不活跃的chunk。</p>
<h2 id="诊断日志">诊断日志</h2>
<p>诊断日志对分析系统极其重要，并且文中提到由于诊断日志是顺序、异步写操作，所以对性能影响很小。</p>
<h1 id="性能分析">性能分析</h1>
<p>忽略掉，这块确实很难讲2333</p>
<h1 id="经验">经验</h1>
<p>文中就简单提了几个关于Linux内核的问题。</p>
<p>暂时先写这么多吧。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yingjie Fan"
      src="/images/%E5%A4%B4%E5%83%8F.png">
  <p class="site-author-name" itemprop="name">Yingjie Fan</p>
  <div class="site-description" itemprop="description">飞得比别人高</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fanyingjie11" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fanyingjie11" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/yjfan_1@foxmail.com" title="E-Mail → yjfan_1@foxmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://fanyingjie11.github.io/2022/04/13/GFS%E8%AF%BB%E5%90%8E%E7%AC%94%E8%AE%B0/" title="https:&#x2F;&#x2F;fanyingjie11.github.io&#x2F;2022&#x2F;04&#x2F;13&#x2F;GFS%E8%AF%BB%E5%90%8E%E7%AC%94%E8%AE%B0&#x2F;">GFS笔记</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; Wed Apr 13 2022 08:00:00 GMT+0800 (中国标准时间) – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yingjie Fan</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


</body>

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
</html>
